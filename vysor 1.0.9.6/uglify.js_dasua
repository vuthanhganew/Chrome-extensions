function nextTick(e) {
    setTimeout(e, 0)
}

function make4Len16(e) {
    var t = e.toString(16);
    while (t.length < 4) {
        t = "0" + t
    }
    return t
}
var pendingFuncs;
window.addEventListener("message", function() {
    if (pendingFuncs) {
        $.each(pendingFuncs, function(e, t) {
            t()
        });
        pendingFuncs = null
    }
}, false);

function unsafeCallback(e) {
    return e
}

function encode_utf8(e) {
    return unescape(encodeURIComponent(e))
}

function decode_utf8(e) {
    return decodeURIComponent(escape(e))
}

function ab2str(e) {
    if (e.constructor.name == "ArrayBuffer") {
        e = new Uint8Array(e)
    }
    return decode_utf8(String.fromCharCode.apply(null, e))
}

function str2ab(e, t, n) {
    e = encode_utf8(e);
    var o = e.length;
    if (n) o++;
    if (!t) {
        t = new ArrayBuffer(o)
    }
    var i = new Uint8Array(t);
    if (n) i[e.length] = 0;
    for (var r = 0, s = e.length; r < s; r++) {
        i[r] = e.charCodeAt(r)
    }
    return t
}
var slashN = "\n".charCodeAt(0);

function writeLine(e, t, n) {
    if (t.constructor.name == "Object") t = JSON.stringify(t);
    writeString(e, t + "\n", n)
}

function readLine(e, t) {
    var n = [];

    function o() {
        e.read(function(i) {
            for (var r = 0; r < i.byteLength; r++) {
                if (i[r] == slashN) {
                    var s = i.subarray(0, r);
                    n.push(s);
                    var c = "";
                    for (var a in n) {
                        a = n[a];
                        c += ab2str(a)
                    }
                    var d = i.subarray(r + 1);
                    e.unshift(d);
                    t(c);
                    return
                }
            }
            n.push(i);
            o()
        })
    }
    o()
}

function readString(e, t) {
    var n = "";
    e.onClose = function() {
        t(n)
    };

    function o(t) {
        n += ab2str(t);
        e.read(o)
    }
    e.read(o)
}

function writeString(e, t, n) {
    if (t.constructor.name == "Object") t = JSON.stringify(t);
    e.write(str2ab(t), n)
}

function appendBuffer(e, t) {
    var n = new Uint8Array(e.byteLength + t.byteLength);
    n.set(e, 0);
    n.set(t, e.byteLength);
    return n
}
var timeThing = (new Date).getTime();

function timeTrace(e) {
    var t = (new Date).getTime();
    console.log(e + ": " + (t - timeThing));
    timeThing = t
}

function bufferToHex(e) {
    var t = new Uint8Array(e);
    var n = "";
    for (var o in t) {
        o = t[o];
        if (o < 16) n += "0" + o.toString(16);
        else n += o.toString(16)
    }
    return n
}

function hexToBuffer(e) {
    var t = new ArrayBuffer(e.length / 2);
    var n = new Uint8Array(t);
    for (var o = 0; o < e.length / 2; o++) {
        var i = e.substr(o * 2, 2);
        n[o] = parseInt(i, 16)
    }
    return t
}

function base64ToArrayBuffer(e) {
    var t = window.atob(e);
    var n = t.length;
    var o = new Uint8Array(n);
    for (var i = 0; i < n; i++) {
        var r = t.charCodeAt(i);
        o[i] = r
    }
    return o.buffer
}

function arrayBufferToBase64(e) {
    var t = "";
    var n = new Uint8Array(e);
    var o = n.byteLength;
    for (var i = 0; i < o; i++) {
        t += String.fromCharCode(n[i])
    }
    return window.btoa(t)
}
var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";

function hex2b64(e) {
    var t;
    var n;
    var o = "";
    for (t = 0; t + 3 <= e.length; t += 3) {
        n = parseInt(e.substring(t, t + 3), 16);
        o += b64map.charAt(n >> 6) + b64map.charAt(n & 63)
    }
    if (t + 1 == e.length) {
        n = parseInt(e.substring(t, t + 1), 16);
        o += b64map.charAt(n << 2)
    } else if (t + 2 == e.length) {
        n = parseInt(e.substring(t, t + 2), 16);
        o += b64map.charAt(n >> 2) + b64map.charAt((n & 3) << 4)
    }
    while ((o.length & 3) > 0) {
        o += b64pad
    }
    return o
}
if (!String.prototype.startsWith) {
    Object.defineProperty(String.prototype, "startsWith", {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function(e, t) {
            t = t || 0;
            return this.lastIndexOf(e, t) === t
        }
    })
}

function getQueryVariable(e, t) {
    if (!t) t = window.location;
    var n = t.search.substring(1);
    var o = n.split("&");
    for (var i = 0; i < o.length; i++) {
        var r = o[i].split("=");
        if (decodeURIComponent(r[0]) == e) {
            return decodeURIComponent(r[1])
        }
    }
}
Object.fromArray = function(e) {
    var t = {};
    for (var n in e) {
        var o = e[n];
        t[o] = o
    }
    return t
};
$.ajaxTransport("+binary", function(e, t, n) {
    if (window.FormData && (e.dataType && e.dataType == "binary" || e.data && (window.ArrayBuffer && e.data instanceof ArrayBuffer || window.Blob && e.data instanceof Blob))) {
        return {
            send: function(t, n) {
                var o = new XMLHttpRequest,
                    i = e.url,
                    r = e.type,
                    s = e.async || true,
                    c = e.responseType || "blob",
                    a = e.data || null,
                    d = e.username || null,
                    u = e.password || null;
                o.addEventListener("load", function() {
                    var t = {};
                    t[e.dataType] = o.response;
                    n(o.status, o.statusText, t, o.getAllResponseHeaders())
                });
                o.open(r, i, s, d, u);
                for (var f in t) {
                    o.setRequestHeader(f, t[f])
                }
                o.responseType = c;
                o.send(a)
            },
            abort: function() {
                n.abort()
            }
        }
    }
});

function throttleTimeout(e, t, n, o) {
    if (e) {
        clearTimeout(e.timeout)
    } else {
        e = {
            items: []
        }
    }
    e.timeout = setTimeout(function() {
        o(e.items);
        e.items = []
    }, n);
    e.items.push(t);
    return e
}

function copyTextToClipboard(e) {
    var t = document.createElement("textarea");
    t.style.position = "fixed";
    t.style.top = 0;
    t.style.left = 0;
    t.style.width = "2em";
    t.style.height = "2em";
    t.style.padding = 0;
    t.style.border = "none";
    t.style.outline = "none";
    t.style.boxShadow = "none";
    t.style.background = "transparent";
    t.value = e;
    document.body.appendChild(t);
    t.select();
    try {
        var n = document.execCommand("copy")
    } catch (o) {
        console.log("Oops, unable to copy")
    }
    document.body.removeChild(t)
}

function showNotification(e, t) {
    t = t || "/icon.png";
    console.log("notification:", e);
    if (!window.chrome || !window.chrome.notifications) return;
    var n = chrome.runtime.getManifest().name;
    chrome.notifications.create({
        type: "basic",
        iconUrl: t,
        title: n,
        message: e
    })
}
var blobFromUrl = function() {
    var e = {};
    return function(t, n) {
        if (e[t]) {
            n(e[t]);
            return
        }
        var o = new XMLHttpRequest;
        o.open("GET", t, true);
        o.responseType = "blob";
        o.onload = function(o) {
            n(e[t] = window.URL.createObjectURL(this.response))
        };
        o.send()
    }
}();
if (window.chrome && window.chrome.sockets) {
    chrome.sockets.tcp.onReceive.addListener(function(e) {
        var t = Socket.readers[e.socketId];
        if (t == null) return;
        t.dataReceived(new Uint8Array(e.data))
    });
    chrome.sockets.tcp.onReceiveError.addListener(function(e) {
        var t = Socket.readers[e.socketId];
        if (t == null) return;
        t.destroy();
        t.dataReceived(null)
    });
    chrome.sockets.tcpServer.onAccept.addListener(function(e) {
        chrome.sockets.tcp.setPaused(e.clientSocketId, false);
        var t = Server.listeners[e.socketId];
        if (t == null) return;
        t(new Socket({
            socketId: e.clientSocketId
        }))
    })
}(function() {
    function e(t, n) {
        if (t.socketId) {
            this.socketId = t.socketId;
            e.readers[this.socketId] = this
        } else {
            chrome.sockets.tcp.create(function(o) {
                this.socketId = o.socketId;
                chrome.sockets.tcp.connect(this.socketId, t.host, t.port, function(t) {
                    chrome.runtime.lastError;
                    if (!t) {
                        e.readers[o.socketId] = this;
                        n(this)
                    } else {
                        this.destroy();
                        n(null)
                    }
                }.bind(this))
            }.bind(this))
        }
    }
    e.readers = {};
    e.connect = function(t, n) {
        return new e(t, n)
    };
    e.pump = function(e, t, n) {
        var o = function() {
            e.read(i)
        }.bind(e);
        var i = function(e) {
            var n = e.buffer;
            if (e.byteOffset || e.length != n.byteLength) {
                n = n.slice(e.byteOffset, e.byteOffset + e.length)
            }
            t.write(n, o)
        }.bind(t);
        e.read(i);
        e.onClose = n
    };
    e.stream = function(t, n, o) {
        e.pump(t, n, function() {
            n.destroy();
            if (o) {
                var e = o;
                o = null;
                e()
            }
        });
        e.pump(n, t, function() {
            t.destroy();
            if (o) {
                var e = o;
                o = null;
                e()
            }
        })
    };
    e.eat = function(e) {
        function t() {
            e.read(t)
        }
        t()
    };
    e.prototype.read = function() {
        if (this.pendingCallback) {
            throw new Error("double callback")
        }
        if (this.closed && !this.pending) {
            var e = this.onClose;
            if (e) {
                delete this.onClose;
                e()
            }
            return
        }
        var t = 0;
        if (arguments[t].constructor.name == "Number") {
            this.pendingLength = arguments[t++]
        } else {
            this.pendingLength = 0
        }
        var e = arguments[t];
        if (!this.pending || this.paused) {
            this.pendingCallback = e;
            return
        }
        if (!this.pendingLength) {
            this.pendingLength = this.buffered()
        } else if (this.pendingLength > this.buffered()) {
            this.pendingCallback = e;
            return
        }
        var n;
        var o = 0;
        while (o < this.pendingLength) {
            var i = this.pending.shift();
            this.bufferedLength -= i.length;
            if (!this.pending.length) delete this.pending;
            var r = i;
            var s = Math.min(r.byteLength, this.pendingLength - o);
            if (s != r.byteLength) {
                var c = r.subarray(0, s);
                var a = r.subarray(s);
                this.unshift(a);
                r = c
            }
            if (!n && r.byteLength != this.pendingLength) n = new Uint8Array(this.pendingLength);
            if (n) {
                n.set(r, o)
            } else {
                n = r
            }
            o += r.byteLength
        }
        e(n)
    };
    e.prototype.write = function(e, t) {
        chrome.sockets.tcp.send(this.socketId, e, function(n) {
            chrome.runtime.lastError;
            if (!n || n.resultCode) {
                return
            }
            if (n.bytesSent < e.byteLength) {
                this.write(e.slice(n.bytesSent), t)
            } else {
                t()
            }
        }.bind(this))
    };
    e.prototype.destroy = function(e, t) {
        chrome.sockets.tcp.close(this.socketId, function() {
            chrome.runtime.lastError
        })
    };
    e.prototype.unshift = function(e) {
        if (e.byteLength == 0) return;
        if (!this.pending) this.pending = [e];
        else this.pending.unshift(e);
        if (!this.bufferedLength) this.bufferedLength = 0;
        this.bufferedLength += e.length
    };
    e.prototype.dataReceived = function(e) {
        if (e && e.length) {
            var t = new Uint8Array(e);
            if (!this.pending) this.pending = [t];
            else this.pending.push(t)
        }
        if (e == null) {
            this.closed = true
        } else {
            if (!this.bufferedLength) this.bufferedLength = 0;
            this.bufferedLength += e.length
        }
        if (this.paused || !this.pending || !this.pending.length) {
            var n = this.onClose;
            if (this.closed && n) {
                delete this.onClose;
                n()
            }
            return
        }
        var o = this.pendingLength;
        var n = this.pendingCallback;
        if (n) {
            delete this.pendingCallback;
            this.read(o, n)
        }
    };
    e.prototype.buffered = function() {
        return this.bufferedLength
    };
    e.prototype.pause = function() {
        if (this.paused) {
            return
        }
        this.paused = true;
        this.onPause()
    };
    e.prototype.resume = function() {
        if (!this.paused) {
            return
        }
        this.paused = false;
        this.onResume()
    };
    e.prototype.onResume = function() {
        chrome.sockets.tcp.setPaused(this.socketId, false, function() {})
    };
    e.prototype.onPause = function() {
        chrome.sockets.tcp.setPaused(this.socketId, true, function() {})
    };

    function t() {}
    t.listeners = {};
    t.prototype.__proto__ = e.prototype;
    t.prototype.destroy = function() {
        chrome.sockets.tcpServer.close(this.socketId)
    };
    t.prototype.listen = function(e, n, o) {
        var i;
        var r;
        if (e.constructor.name == "Number") {
            i = e;
            r = "0.0.0.0"
        } else {
            r = e.address;
            i = e.port
        }
        chrome.sockets.tcpServer.create(function(e) {
            this.socketId = e.socketId;
            t.listeners[this.socketId] = n;
            chrome.sockets.tcpServer.listen(e.socketId, r, i, function(e) {
                chrome.runtime.lastError;
                if (e) {
                    this.destroy();
                    if (o) {
                        o(e)
                    }
                    return
                }
                chrome.sockets.tcpServer.getInfo(this.socketId, function(t) {
                    this.localAddress = t.localAddress;
                    this.localPort = t.localPort;
                    if (o) {
                        o(e)
                    }
                }.bind(this))
            }.bind(this))
        }.bind(this))
    };
    window.Socket = e;
    window.Server = t
})();

function DummySocket(e) {
    this.dataReceived(e);
    this.dataReceived(null)
}
DummySocket.prototype.write = function(e, t) {
    throw new Error("write not supported on dummy socket")
};
DummySocket.prototype.destroy = function() {};
DummySocket.prototype.buffered = Socket.prototype.buffered;
DummySocket.prototype.unshift = Socket.prototype.unshift;
DummySocket.prototype.dataReceived = Socket.prototype.dataReceived;
DummySocket.prototype.read = Socket.prototype.read;
DummySocket.prototype.pause = Socket.prototype.pause;
DummySocket.prototype.resume = Socket.prototype.resume;
DummySocket.prototype.buffered = Socket.prototype.buffered;
DummySocket.prototype.onPause = function() {};
DummySocket.prototype.onResume = function() {};

function FetchSocket(e, t) {
    this.promise = fetch(e).then(function(e) {
        this.connected = true;
        this.response = e;
        this.reader = this.response.body.getReader();
        this.reader.closed.then(function() {
            if (this.onClose) this.dataReceived(null)
        }.bind(this));
        this.onResume();
        t(this)
    }.bind(this), function(e) {
        t(null, e)
    })
}
FetchSocket.connect = function(e, t) {
    new FetchSocket(e, t)
};
FetchSocket.prototype.write = function(e, t) {
    throw new Error("write not supported on fetch socket")
};
FetchSocket.prototype.destroy = function() {
    if (this.promise && this.promise.cancel) this.promise.cancel()
};
FetchSocket.prototype.unshift = Socket.prototype.unshift;
FetchSocket.prototype.dataReceived = Socket.prototype.dataReceived;
FetchSocket.prototype.read = Socket.prototype.read;
FetchSocket.prototype.pause = Socket.prototype.pause;
FetchSocket.prototype.resume = Socket.prototype.resume;
FetchSocket.prototype.buffered = Socket.prototype.buffered;
FetchSocket.prototype.onPause = function() {};
FetchSocket.prototype.onResume = function() {
    this.reader.read().then(function(e) {
        if (!e.value) return;
        this.dataReceived(e.value);
        if (this.paused) {
            return
        }
        this.onResume()
    }.bind(this))
};
(function() {
    function e(e, t) {
        this.conn = e;
        this.dc = t;
        this.gotEof = false;
        t.onmessage = function(e) {
            var t = new Uint8Array(e.data);
            var n = t[t.byteLength - 1] == 1;
            this.dataReceived(t.subarray(0, t.byteLength - 1));
            if (n) {
                this.gotEof = true;
                this.destroy()
            }
        }.bind(this);
        t.onclose = t.onerror = this.destroy.bind(this);
        this.needsBufferShim = true || parseInt(/Chrome\/(\d\d)/.exec(navigator.userAgent)[1]) < 46
    }
    e.prototype.buffered = Socket.prototype.buffered;
    e.prototype.unshift = Socket.prototype.unshift;
    e.prototype.dataReceived = Socket.prototype.dataReceived;
    e.prototype.read = Socket.prototype.read;
    e.prototype.pause = Socket.prototype.pause;
    e.prototype.resume = Socket.prototype.resume;
    e.prototype.buffered = Socket.prototype.buffered;
    e.prototype.writeable = function() {
        var e = this.writeCallback;
        if (e) {
            delete this.writeCallback;
            e()
        }
    };
    e.prototype.write = function(e, t) {
        if (!this.dc || this.dc.readyState != "open") {
            this.destroy();
            return
        }
        this.writeCallback = t;
        var n = new Uint8Array(e.byteLength + 1);
        n.set(new Uint8Array(e));
        this.dc.send(n.buffer);
        if (this.reentrantWrite) return;
        try {
            this.reentrantWrite = true;
            while (this.writeCallback && (this.dc.bufferedAmount == 0 || this.needsBufferShim)) {
                this.writeable()
            }
        } finally {
            this.reentrantWrite = false
        }
    };
    e.prototype.destroy = function() {
        this.dataReceived(null);
        if (this.dc == null) return;
        var e = this.dc;
        this.dc = null;
        e.onclose = null;
        e.onerror = null;
        if (e.readyState == "open") {
            try {
                e.send(new Uint8Array([1]));
                if (this.gotEof) this.conn.recycleChannel(e);
                else this.conn.waitForEof(e)
            } catch (t) {}
        }
    };

    function t(e) {
        this.pc = e;
        this.pc.oniceconnectionstatechange = function() {
            if (this.pc.iceConnectionState == "disconnected" || this.pc.iceConnectionState == "closed") {
                this.destroy()
            }
        }.bind(this)
    }
    t.prototype.waitForCommand = function(t) {
        t.onmessage = function(n) {
            if (n.data.byteLength == 1) return;
            this.removeChannel(t);
            var o = ab2str(n.data);
            var i = new e(this, t);
            this.openSocket(o, i)
        }.bind(this)
    };
    t.prototype.compactChannels = function() {
        if (this.channels && !this.channels.length) this.channels = null
    };
    t.prototype.removeChannel = function(e) {
        t;
        if (!this.channels) return;
        var t = this.channels.indexOf(e);
        if (t == -1) return;
        this.channels.splice(t, 1);
        this.compactChannels()
    };
    t.prototype.waitForEof = function(e) {
        e.onmessage = function(t) {
            var n = new Uint8Array(t.data);
            var o = n[n.byteLength - 1] == 1;
            if (o) this.recycleChannel(e)
        }.bind(this)
    };
    t.prototype.recycleChannel = function(e) {
        if (!this.channels) this.channels = [];
        this.channels.push(e);
        e.onclose = e.onerror = function() {
            this.removeChannel(e)
        }.bind(this);
        this.waitForCommand(e)
    };
    t.prototype.addCandidates = function(e) {
        for (var t in e.candidates) {
            this.pc.addIceCandidate(new RTCIceCandidate(e.candidates[t]))
        }
    };
    t.prototype.setupPinger = function(e) {
        var t;

        function n() {
            e.send(str2ab("ping"));
            t = setTimeout(n, 1e3)
        }
        e.onmessage = function(e) {};
        e.onclose = e.onerror = function() {
            clearTimeout(t);
            this.destroy()
        }.bind(this);
        n()
    };
    t.prototype.listenSockets = function() {
        this.pc.ondatachannel = function(e) {
            this.waitForCommand(e.channel)
        }.bind(this)
    };
    t.prototype.prepareChannel = function(e) {
        var t = this.pc.createDataChannel(e || "gcm", {
            reliable: true,
            ordered: true
        });
        t.binaryType = "arraybuffer";
        return t
    };
    t.prototype.newSocket = function(t, n) {
        if (this.channels) {
            var o = this.channels.shift();
            this.compactChannels();
            o.send(str2ab(t));
            var i = new e(this, o);
            n(i, this);
            return
        }
        var o = this.prepareChannel("gcm");
        o.onopen = function() {
            o.send(str2ab(t));
            var i = new e(this, o);
            n(i, this)
        }.bind(this)
    };
    t.prototype.destroy = function() {
        if (this.pc.signalingState != "closed") {
            this.pc.close()
        }
        var e = this.onClose;
        if (e) {
            delete this.onClose;
            e()
        }
    };

    function n(e, t, n, o) {
        this.senderId = e;
        this.registrationId = n;
        this.authorization = t;
        this.rtcc = o
    }
    n.gcmRtcConnections = {};
    n.onMessage = function(e) {
        var t = JSON.parse(e.message);
        console.log("gcm message", t);
        var o = e.type;
        var i = e.src;
        var r = e.srcPort;
        var s = e.dstPort;
        if (o == "offer") {
            var c = n.gcmRtcListeners[s];
            if (!c) console.log("not listening on " + s);
            else c.listener.incoming(i, r, s, t, c.listenCallback);
            return
        } else if (o == "answer") {
            var a = n.getKey(i, r, s);
            var d = n.gcmRtcConnections[a];
            if (!d) {
                console.log("pending connection not found");
                return
            }
            d.manager.incoming(i, r, s, t);
            return
        }
        console.log("unknown message " + o)
    };
    n.hasLoadedChannels = false;
    n.start = function(e, t, o, i) {
        if (window.chrome && window.chrome.gcm) {
            chrome.gcm.register([e], function(r) {
                console.log("gcm registration " + r);
                if (!r) {
                    i();
                    return
                }
                var s = new n(e, t, r, o);
                i(s)
            })
        } else {
            function r() {
                $.ajax({
                    type: "GET",
                    url: "https://vysor-1026.appspot.com/listen",
                    success: function(r) {
                        console.log(r);
                        var s = new goog.appengine.Channel(r.token);
                        var c = {
                            onopen: function() {
                                var s = new n(e, t, "web:" + r.channel, o);
                                i(s)
                            },
                            onmessage: function(e) {
                                n.onMessage(JSON.parse(e.data))
                            },
                            onerror: function() {
                                console.log("error", arguments)
                            },
                            onclose: function() {
                                console.log("onclose", arguments)
                            }
                        };
                        var a = s.open(c)
                    }
                })
            }
            if (n.hasLoadedChannels) {
                r()
            } else {
                $.getScript("https://vysor-1026.appspot.com/_ah/channel/jsapi", r)
            }
        }
        if (window.chrome && window.chrome.gcm) {
            chrome.gcm.onMessage.addListener(function(e) {
                n.onMessage(e.data)
            })
        }
    };
    n.prototype.sendGcm = function(e, t, n, o, i) {
        if (e.startsWith("web:")) {
            $.ajax({
                type: "POST",
                url: "https://vysor-1026.appspot.com/send",
                data: JSON.stringify({
                    channel: e.substring(4),
                    data: {
                        src: this.registrationId,
                        srcPort: n,
                        dstPort: t,
                        type: o,
                        message: JSON.stringify(i)
                    }
                }),
                contentType: "application/json",
                dataType: "json",
                success: function() {}
            })
        } else {
            $.ajax({
                type: "POST",
                url: "https://gcm-http.googleapis.com/gcm/send",
                headers: {
                    Authorization: "key=" + this.authorization
                },
                data: JSON.stringify({
                    to: e,
                    data: {
                        src: this.registrationId,
                        srcPort: n,
                        dstPort: t,
                        type: o,
                        message: JSON.stringify(i)
                    }
                }),
                contentType: "application/json",
                dataType: "json",
                error: function() {
                    console.log("gcm error", arguments)
                },
                success: function() {
                    console.log("gcm", arguments)
                }
            })
        }
    };
    n.getKey = function(e, t, n) {
        return n + ":" + t + ":" + e
    };
    n.prototype.setupPeerConnection = function(e, o, i, r, s) {
        var c = window.RTCPeerConnection || window.webkitRTCPeerConnection;
        var a = new c(this.rtcc);
        var d;
        var u = function(t) {
            this.sendGcm(o, i, r, e, {
                desc: s(),
                candidates: t
            })
        }.bind(this);
        a.onicecandidate = function(e) {
            if (e.candidate == null) return;
            console.log(e.candidate);
            d = throttleTimeout(d, e.candidate, 5e3, u)
        }.bind(this);
        var f = n.getKey(o, i, r);
        var l = new t(a);
        l.manager = this;
        var h;
        a.onsignalingstatechange = function(e) {
            if (a.signalingState == "stable") {
                if (n.gcmRtcConnections[f] == l) {
                    delete n.gcmRtcConnections[f]
                }
            } else if (a.signalingState == "closed") {
                l.destroy()
            }
        };
        n.gcmRtcConnections[f] = l;
        return l
    };
    n.gcmPortCount = 0;
    n.prototype.connect = function(e, t, o) {
        var i = n.gcmPortCount++;
        var r;
        var s = this.setupPeerConnection("offer", e, t, i, function() {
            return r
        }, o);
        var c = s.pc;
        var a = s.prepareChannel("pinger");
        a.onopen = function() {
            console.log("got rtc pinger");
            s.setupPinger(a);
            o(this)
        }.bind(s);
        s.listenSockets();
        c.createOffer(function(e) {
            r = e;
            c.setLocalDescription(e)
        }, function() {})
    };
    n.gcmRtcListeners = {};
    n.prototype.isListening = function(e) {
        return n.gcmRtcListeners[e] != null
    };
    n.prototype.stopListen = function(e) {
        delete n.gcmRtcListeners[e]
    };
    n.prototype.listen = function(e, t) {
        if (n.gcmRtcListeners[e]) {
            console.log("already listening on gcm port " + e);
            return
        }
        n.gcmRtcListeners[e] = {
            listener: this,
            listenCallback: t
        }
    };
    n.prototype.incoming = function(e, t, o, i, r) {
        var s = n.getKey(e, t, o);
        var c = n.gcmRtcConnections[s];
        if (!c) {
            var a;
            c = this.setupPeerConnection("answer", e, t, o, function() {
                return a
            });
            c.remoteDesc = new RTCSessionDescription(i.desc);
            var d = c.pc;
            d.ondatachannel = function(e) {
                console.log("got rtc pinger");
                this.setupPinger(e.channel);
                r(c);
                this.listenSockets()
            }.bind(c);
            d.setRemoteDescription(c.remoteDesc, function() {
                d.createAnswer(function(e) {
                    a = e;
                    d.setLocalDescription(e)
                }, function() {
                    console.log("answer error", arguments)
                })
            })
        } else if (!c.remoteDesc) {
            c.remoteDesc = new RTCSessionDescription(i.desc);
            var d = c.pc;
            d.setRemoteDescription(c.remoteDesc)
        }
        c.addCandidates(i)
    };
    window.GcmRtcSocket = e;
    window.GcmRtcManager = n
})();
(function() {
    function e(e, t) {
        this.handle = e;
        this.iface = t;
        this.type = "usb";
        for (var n in t.endpoints) {
            n = t.endpoints[n];
            if (n.type == "bulk") {
                this.zero_mask = n.maximumPacketSize - 1;
                if (n.direction == "in") {
                    this.in = n
                } else {
                    this.out = n
                }
            }
        }
    }
    e.prototype.destroy = function() {
        chrome.usb.releaseInterface(this.handle, this.iface.interfaceNumber, function() {
            chrome.usb.closeDevice(this.handle, function() {})
        }.bind(this))
    };
    e.prototype.write = function(e, t) {
        if (this.writing) {
            if (!this.pendingWrites) this.pendingWrites = [];
            this.pendingWrites.push({
                data: e,
                callback: t
            });
            return
        }
        var n = {
            direction: "out",
            endpoint: this.out.address,
            data: e
        };
        this.writing = true;
        chrome.usb.bulkTransfer(this.handle, n, function(e) {
            this.writing = false;
            t(e);
            if (!this.pendingWrites) return;
            var n = this.pendingWrites.shift();
            if (!this.pendingWrites.length) this.pendingWrites = null;
            this.write(n.data, n.callback)
        }.bind(this))
    };
    e.prototype.read = function(e, t) {
        var n = {
            direction: "in",
            endpoint: this.in.address,
            length: e
        };
        chrome.usb.bulkTransfer(this.handle, n, unsafeCallback(t))
    };

    function t(e) {
        this.socket = e;
        this.zero_mask = (1 << 30) - 1;
        this.type = "tcp";
        e.onClose = function() {
            var e = this.currentRead;
            if (e) {
                delete this.currentRead;
                e({
                    resultCode: -1
                })
            }
        }.bind(this)
    }
    t.prototype.destroy = function() {
        this.socket.destroy()
    };
    t.prototype.write = function(e, t) {
        if (this.writing) {
            if (!this.pendingWrites) this.pendingWrites = [];
            this.pendingWrites.push({
                data: e,
                callback: t
            });
            return
        }
        this.writing = true;
        this.socket.write(e, function() {
            this.writing = false;
            t({
                resultCode: 0
            });
            if (!this.pendingWrites) return;
            var e = this.pendingWrites.shift();
            if (!this.pendingWrites.length) this.pendingWrites = null;
            this.write(e.data, e.callback)
        }.bind(this))
    };
    t.prototype.read = function(e, t) {
        this.currentRead = t;
        this.socket.read(e, function(e) {
            delete this.currentRead;
            t({
                resultCode: 0,
                data: e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)
            })
        })
    };

    function n(e, t) {
        this.onConnected = t;
        this.transport = e;
        this.currentSocketId = 0;
        this.sockets = {};
        this.forwards = {};
        this.maxPayload = n.MAX_PAYLOAD
    }
    n.prototype.fatal = function(e) {
        console.log("fatal error", JSON.stringify(e));
        var t = this.onConnected;
        if (t) {
            delete this.onConnected;
            t()
        } else if (this.onError) {
            this.onError();
            delete this.onError
        }
        this.destroy()
    };
    n.prototype.destroy = function() {
        for (var e in this.sockets) {
            e = this.sockets[e];
            e.dataReceived(null)
        }
        if (this.forwards) {
            $.each(this.forwards, function(e, t) {
                t.destroy()
            })
        }
        this.transport.destroy()
    };
    n.kCommandSYNC = 1129208147, n.kCommandCNXN = 1314410051, n.kCommandOPEN = 1313165391, n.kCommandOKAY = 1497451343, n.kCommandCLSE = 1163086915, n.kCommandWRTE = 1163154007, n.kCommandAUTH = 1213486401;
    n.kAuthToken = 1;
    n.kAuthSignature = 2;
    n.kAuthRSAPublicKey = 3;
    n.ADB_PROTOCOL_VERSION = 16777216;
    n.ADB_VERSION = 36;
    n.MAX_PAYLOAD = 4096;
    n.checksum = function(e) {
        e = new Uint8Array(e);
        var t = 0;
        for (var n = 0; n < e.byteLength; n++) {
            t += e[n]
        }
        return t & 4294967295
    };
    n.prototype.sendMessage = function(e, t, o, i, r) {
        if (!i) {
            i = ""
        }
        if (i.constructor.name == "String") {
            i = str2ab(i)
        }
        var s = true;
        if (!i.byteLength) {
            s = false
        }
        if (e == n.kCommandAUTH && t == n.kAuthSignature) {
            s = false
        }
        if (e == n.kCommandWRTE) {
            s = false
        }
        var c = i.byteLength;
        if (s) {
            c++
        }
        if (s) {
            var a = new ArrayBuffer(i.byteLength + 1);
            var d = new Uint8Array(a);
            d.set(new Uint8Array(i));
            d[a.byteLength - 1] = 0;
            i = a
        }
        var u = new ArrayBuffer(24);
        var d = new DataView(u);
        d.setUint32(0, e, true);
        d.setUint32(4, t, true);
        d.setUint32(8, o, true);
        d.setUint32(12, c, true);
        d.setUint32(16, n.checksum(i), true);
        d.setUint32(20, e ^ 4294967295, true);
        this.transport.write(u, function(e) {
            if (e.resultCode) {
                this.fatal(e)
            }
            if (!i.byteLength && r) {
                r()
            }
        }.bind(this));
        if (i.byteLength) {
            this.transport.write(i, function(e) {
                if (e.resultCode) {
                    this.fatal(e)
                }
                if (r) {
                    r()
                }
            }.bind(this))
        }
    };
    n.prototype.getKey = function(e) {
        chrome.storage.local.get("adbkey", function(t) {
            var n = t.adbkey;
            var o = new JSEncrypt({
                default_key_size: 2048
            });
            if (!n) {
                n = o.getPrivateKeyB64();
                o.setPrivateKey(n);
                chrome.storage.local.set({
                    adbkey: n
                })
            } else {
                o.setPrivateKey(n)
            }
            e(o)
        })
    };
    n.prototype._convertToMinCrypt = function(e) {
        var t = 2048;
        var n = t / 8 / 4;
        var o = BigInteger.ONE.shiftLeft(32);
        var i = e.n.clone();
        var r = BigInteger.ONE.shiftLeft(1).pow(t);
        var s = r.multiply(r).mod(i);
        var c = new Uint32Array(3 + n * 2);
        c[0] = n;
        c[1] = o.subtract(i.modInverse(o)).intValue();
        var a = n + 2;
        for (var d = 2, u = 2 + n; d < a; ++d, ++u) {
            c[d] = i.mod(o).intValue();
            i = i.divide(o);
            c[u] = s.mod(o).intValue();
            s = s.divide(o)
        }
        c[c.length - 1] = e.e;
        var f = "";
        var l = new Uint8Array(c.buffer);
        for (var d = 0; d < l.length; ++d) {
            var h = l[d].toString(16);
            if (h.length == 1) {
                f += "0"
            }
            f += h
        }
        return hex2b64(f) + " adb@chrome"
    };
    n.prototype.sign = function(e, t) {
        if (e == null) {
            throw "AuthManager is not initialized"
        }
        var n = 2048 / 8;
        var o = new Uint8Array(n);
        o[0] = 0;
        o[1] = 1;
        var i = [0, 48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20];
        var r = n - i.length - t.byteLength;
        for (var s = 2; s < r; s++) {
            o[s] = 255
        }
        o.set(new Uint8Array(i), r);
        r += i.length;
        o.set(new Uint8Array(t), r);
        var c = new BigInteger(Array.apply([], o));
        return new Uint8Array(e.doPrivate(c).toByteArray()).buffer
    };

    function o(e) {
        var t = {};
        e = ab2str(e);
        var n = e.replace("device::", "").split(";");
        for (var o in n) {
            o = n[o];
            var i = o.split("=");
            if (i.length == 2) {
                t[i[0]] = i[1]
            }
        }
        return t
    }
    n.prototype.handleUnknown = function(e, t) {
        console.log("no idea what this socket is.");
        this.sendMessage(n.kCommandCLSE, e, t)
    };
    n.prototype.receiveMessages = function() {
        this.transport.read(24, function(e) {
            if (e.resultCode) {
                this.fatal(e);
                return
            }
            var t = new DataView(e.data);
            var i = t.getUint32(0, true);
            var r = t.getUint32(4, true);
            var s = t.getUint32(8, true);
            var c = t.getUint32(12, true);
            var a = t.getUint32(16, true);
            var d = t.getUint32(12, true);
            var u = function(e) {
                switch (i) {
                    case n.kCommandOPEN:
                        if (this.onOpenSocket) this.onOpenSocket(e, r);
                        break;
                    case n.kCommandAUTH:
                        console.log("auth:", this);
                        this.getKey(function(t) {
                            if (this.sentSignature) {
                                var o = this._convertToMinCrypt(t.getKey());
                                this.sendMessage(n.kCommandAUTH, n.kAuthRSAPublicKey, 0, o);
                                showNotification('Check your Android device and click "Allow USB Debugging".')
                            } else {
                                this.sentSignature = true;
                                var i = this.sign(t.getKey(), e);
                                this.sendMessage(n.kCommandAUTH, n.kAuthSignature, 0, i, function() {})
                            }
                        }.bind(this));
                        break;
                    case n.kCommandOKAY:
                        var t = r;
                        var c = s;
                        var a = this.sockets[c];
                        if (!a) {
                            this.handleUnknown(c, t);
                            return
                        }
                        var d = a.onConnected;
                        if (d) {
                            delete a.onConnected;
                            a.remoteId = t;
                            d(a)
                        }
                        var u = a.pendingWrite;
                        if (u) {
                            d = a.wrote;
                            delete a.wrote;
                            delete a.pendingWrite;
                            a.write(u, d);
                            return
                        }
                        d = a.wrote;
                        if (d) {
                            delete a.wrote;
                            d()
                        }
                        break;
                    case n.kCommandCNXN:
                        this.rawProperties = ab2str(e);
                        this.properties = o(e);
                        var d = this.onConnected;
                        if (d) {
                            delete this.onConnected;
                            d(this)
                        }
                        break;
                    case n.kCommandWRTE:
                        var t = r;
                        var c = s;
                        var a = this.sockets[c];
                        if (!a) {
                            this.handleUnknown(c, t);
                            return
                        }
                        if (!a.paused) {
                            this.sendMessage(n.kCommandOKAY, a.localId, a.remoteId)
                        }
                        a.dataReceived(new Uint8Array(e));
                        break;
                    case n.kCommandCLSE:
                        var t = r;
                        var c = s;
                        var a = this.sockets[c];
                        if (!a) {
                            console.log("asked to close unknown socket?");
                            return
                        }
                        delete this.sockets[c];
                        a.destroy();
                        var d = a.onConnected;
                        if (d) {
                            delete a.onConnected;
                            d()
                        }
                        break;
                    default:
                        console.log("unknown command: ", i.toString(16), r, s, e);
                        break
                }
            }.bind(this);
            if (!d) {
                try {
                    u(null)
                } finally {
                    this.receiveMessages()
                }
                return
            }
            this.transport.read(d, function(e) {
                if (e.resultCode) {
                    this.fatal(e);
                    return
                }
                var o = e.data;
                if (n.checksum(o) != t.getUint32(16, true)) {
                    this.receiveMessages();
                    return
                }
                try {
                    u(o)
                } finally {
                    this.receiveMessages()
                }
            }.bind(this))
        }.bind(this))
    };
    n.prototype.forwardPort = function(e) {
        var t = new Server;
        t.listen({
            port: e.fromPort,
            address: "127.0.0.1"
        }, function(t) {
            this.newSocket(e.to, function(e) {
                if (e) Socket.stream(t, e);
                else t.destroy()
            }.bind(this))
        }.bind(this), function() {
            this.forwards[e.fromPort] = t
        }.bind(this))
    };
    n.prototype.newAdbSocket = function(e, t) {
        var n;
        if (this.createSocket) n = this.createSocket(e, t);
        else n = new i(this, e, t);
        return n
    };
    n.prototype.newSocket = function(e, t) {
        var o = ++this.currentSocketId;
        this.sockets[o] = this.newAdbSocket(o, t);
        this.sendMessage(n.kCommandOPEN, o, 0, e)
    };

    function i(e, t, n) {
        if (!n) {
            n = function() {}
        }
        this.device = e;
        this.localId = t;
        this.onConnected = n
    }
    i.prototype.write = function(e, t) {
        if (this.pendingWrite || this.wrote) {
            console.log("bad adb socket state, already writing");
            throw new Error("bad adb socket state, already writing")
        }
        var o = Math.min(this.device.transport.zero_mask, this.device.maxPayload);
        if (o < e.byteLength) {
            this.pendingWrite = e.slice(o);
            e = e.slice(0, o)
        } else {
            this.pendingWrite = null
        }
        this.wrote = t;
        this.device.sendMessage(n.kCommandWRTE, this.localId, this.remoteId, e)
    };
    i.prototype.destroy = function() {
        this.device.sendMessage(n.kCommandCLSE, this.localId, this.remoteId);
        this.dataReceived(null)
    };
    i.prototype.buffered = Socket.prototype.buffered;
    i.prototype.dataReceived = Socket.prototype.dataReceived;
    i.prototype.read = Socket.prototype.read;
    i.prototype.pause = Socket.prototype.pause;
    i.prototype.resume = Socket.prototype.resume;
    i.prototype.unshift = Socket.prototype.unshift;
    i.prototype.onPause = function() {};
    i.prototype.onResume = function() {
        this.device.sendMessage(n.kCommandOKAY, this.localId, this.remoteId)
    };

    function r(t, o, i) {
        console.log("connecting");
        var r = new n(new e(t, o), i);
        console.log("sending CNXN");
        r.sendMessage(n.kCommandCNXN, n.ADB_PROTOCOL_VERSION, n.MAX_PAYLOAD, "host::");
        console.log("starting receive loop");
        r.receiveMessages()
    }

    function s(e) {
        var e = e || {};
        var t = e.port || 5037;
        var n = e.start !== false;
        this.currentSocketId = 0;
        this.pendingDevices = {};
        this.port = t;
        this.adbDevices = {};
        this.clients = {};
        if (n) {
            this.start()
        }
    }

    function c() {
        return (new Date).getTime()
    }
    s.prototype.start = function() {
        if (this.server) {
            console.log("ADB Server started while already started");
            return
        }
        this.lastChange = c();
        this.clients = {};
        this.adbDevices = {};
        this.pendingDevices = {};
        this.refreshing = {};
        var e = new Server;
        e.listen({
            port: this.port,
            address: "127.0.0.1"
        }, function(e) {
            var t = new a(this, e);
            var n = ++this.currentSocketId;
            this.clients[n] = t;
            e.onClose = function() {
                delete this.clients[n]
            }.bind(this);
            t.receiveHeader()
        }.bind(this), function(t) {
            if (t) {
                console.log("adb server failed to listen: " + t);
                return
            }
            console.log("ADB Server started");
            this.server = e;
            this.refresh()
        }.bind(this))
    };
    s.prototype.isRunning = function() {
        return this.server != null
    };
    s.prototype.kill = function() {
        this.lastChange = c();
        this.server.destroy();
        this.server = null;
        this.refreshing = {};
        for (var e in this.clients) {
            e = this.clients[e];
            e.socket.destroy()
        }
        this.clients = {};
        for (var t in this.adbDevices) {
            t = this.adbDevices[t];
            t.destroy()
        }
        this.adbDevices = {};
        this.pendingDevices = {}
    };
    s.prototype.selectDevice = function(e) {
        chrome.usb.getUserSelectedDevices({
            filters: [{
                interfaceClass: 255,
                interfaceSubclass: 66,
                interfaceProtocol: 1
            }]
        }, function(t) {
            for (var n in t) {
                n = t[n];
                this.refreshDevice(n, e)
            }
        }.bind(this))
    };
    s.prototype.withAdbDevice = function(e, t) {
        e.onError = function() {
            this.lastChange = c();
            delete this.adbDevices[e.serialno]
        }.bind(this);
        var n = function(n) {
            this.lastChange = c();
            e.serialno = n.trim();
            this.adbDevices[e.serialno] = e;
            console.log("found device: " + e.serialno);
            t(e)
        }.bind(this);
        if (e.serialno) {
            n(e.serialno);
            return
        }
        e.newSocket("shell:getprop ro.serialno", function(e) {
            readString(e, function(e) {
                n(e)
            }.bind(this))
        }.bind(this))
    };
    s.prototype.tryDevice = function(e, t, n) {
        var o = this.adbDevices;
        var i = this.pendingDevices;
        var s = this;

        function c(o) {
            var c = o.interfaceNumber;
            if (i[c]) {
                return false
            }
            i[c] = e;
            console.log("claiming:", JSON.stringify(e), JSON.stringify(o));
            chrome.usb.claimInterface(e, o.interfaceNumber, function() {
                console.log("claimed:", JSON.stringify(chrome.runtime.lastError));
                r(e, o, function(e) {
                    if (!e) {
                        delete i[c];
                        n();
                        return
                    }
                    e.serialno = t;
                    s.withAdbDevice(e, function(e) {
                        delete i[c];
                        n(e)
                    })
                })
            });
            return true
        }
        chrome.usb.listInterfaces(e, unsafeCallback(function(t) {
            if (!t) {
                console.log("unable list interfaces", JSON.stringify(chrome.runtime.lastError));
                if (n) n();
                return
            }
            console.log("got interfaces", JSON.stringify(t));
            var o = false;
            for (var i in t) {
                i = t[i];
                if (i.interfaceClass == 255 && i.interfaceSubclass == 66 && i.interfaceProtocol == 1) {
                    o |= c(i)
                }
            }
            if (!o) {
                chrome.usb.closeDevice(e)
            }
        }))
    };
    s.prototype.refreshDevice = function(e, t) {
        chrome.usb.openDevice(e, function(n) {
            if (!n) {
                console.log("unable to open device", JSON.stringify(chrome.runtime.lastError));
                if (t) t();
                return
            }
            this.start();
            this.tryDevice(n, e.serialNumber, function(n) {
                if (n) {
                    n.usbDevice = e
                }
                t(n)
            })
        }.bind(this))
    };
    s.prototype.refresh = function() {
        if (!this.server) {
            console.log("adb server refresh requested while server killed");
            return
        }
        var e = c();
        if (this.server.lastRefresh && this.server.lastRefresh > e - 1e4) {
            return
        }
        this.server.lastRefresh = e;
        var t = chrome.runtime.getManifest().permissions.pop().usbDevices;
        $(t).each(function(e, t) {
            var n = t.vendorId + "&" + t.productId;
            if (this.refreshing[n]) {
                return
            }
            this.refreshing[n] = true;
            chrome.usb.findDevices({
                productId: t.productId,
                vendorId: t.vendorId
            }, function(e) {
                var o = e.length;
                if (!o) {
                    delete this.refreshing[n];
                    return
                }
                console.log("found:", t, e);
                for (var i in e) {
                    console.log("trying:", e[i]);
                    this.tryDevice(e[i], e[i].serialNumber, function() {
                        o--;
                        if (!o) {
                            delete this.refreshing[n]
                        }
                    }.bind(this))
                }
            }.bind(this))
        }.bind(this));
        var e = c();
        for (var n in this.clients) {
            n = this.clients[n];
            if (n.tracking && e != n.tracking) {
                n.tracking = e;
                n.writeDevices({
                    filter: n.tracked
                }, function() {})
            }
        }
    };
    s.prototype.stop = function() {
        this.server.destroy()
    };

    function a(e, t) {
        this.server = e;
        this.socket = t
    }
    a.prototype.resolveTransport = function(e, t) {
        if (t) {
            var n = this.server.adbDevices[t];
            if (!n) return "device not found";
            return n
        }
        var o = Object.keys(this.server.adbDevices);
        if (o > 1) {
            return "more than one device"
        }
        if (o == 0) {
            return "no devices connected"
        }
        for (var i in this.server.adbDevices) {
            return this.server.adbDevices[i]
        }
    };
    a.prototype.write = function(e, t, n) {
        if (!t) {
            t = "OKAY"
        }
        e = str2ab(e);
        var o = e.byteLength;
        var i = make4Len16(o);
        i = str2ab(t + i);
        var r = appendBuffer(new Uint8Array(i), new Uint8Array(e)).buffer;
        if (!n) {
            n = function() {
                this.socket.destroy()
            }.bind(this)
        }
        this.socket.write(r, n)
    };
    a.prototype.writeDevices = function(e, t) {
        var e = e || {};
        var n = e.longformDevices;
        var o = e.filter || null;
        var i = "";
        for (var r in this.server.adbDevices) {
            if (o && o[r]) continue;
            r = this.server.adbDevices[r];
            i += r.serialno + "	device";
            if (n) {
                if (r.transport.type == "usb") i += " usb:" + r.transport.iface.interfaceNumber;
                else i += " tpcip:" + "something";
                i += " product:" + r.properties["ro.product.name"];
                i += " model:" + r.properties["ro.product.model"];
                i += " device:" + r.properties["ro.product.device"]
            }
            i += "\n"
        }
        if (o != null && i.length == 0) return;
        this.write(i, null, t)
    };
    a.prototype.handlePayload = function(e) {
        e = ab2str(e);
        var o = e.split(":");
        var i = e;
        var r;
        if (o[0] == "host-serial") {
            o[0] = "host";
            r = o.splice(1, 1)[0];
            if (Number.isInteger(parseInt(o[1]))) {
                r += ":" + o.splice(1, 1)[0]
            }
        }
        if (o.length >= 2) i = o[0] + ":" + o[1];
        switch (i) {
            case "host:version":
                this.write(make4Len16(n.ADB_VERSION));
                break;
            case "host:devices-l":
            case "host:devices":
                var s = e == "host:devices-l";
                this.server.refresh();
                this.writeDevices({
                    longformDevices: s
                });
                break;
            case "host:features":
                var a = this.resolveTransport(e, r);
                if (a.constructor.name == "String") {
                    this.write(a, "FAIL");
                    break
                }
                var d = a.properties.features;
                if (!d) d = "";
                this.write(make4Len16(d));
                break;
            case "host:transport-usb":
            case "host:transport-any":
                var a = this.resolveTransport(e, r);
                if (a.constructor.name == "String") {
                    this.write(a, "FAIL");
                    break
                }
                this.transport = a;
                this.socket.write(str2ab("OKAY"), function() {});
                break;
            case "host:kill":
                this.server.kill();
                break;
            case "host:connect":
                if (o.length < 3) {
                    this.write("need more arguments for connect <host>[:<port>]", "FAIL");
                    break
                }
                var u = o[2];
                var f = 5555;
                if (o.length > 3) f = Number.parseInt(o[3]);
                Socket.connect({
                    host: u,
                    port: f
                }, function(e) {
                    if (!e) {
                        this.write("connecting " + u + " " + f, "FAIL");
                        return this
                    }
                    var o = new n(new t(e), function(e) {
                        this.server.withAdbDevice(e, function() {
                            console.log("connected?");
                            this.socket.write(str2ab("OKAYOKAY"), function() {})
                        }.bind(this))
                    }.bind(this));
                    o.serialno = u + ":" + f;
                    e.onClose = function() {
                        o.fatal("socket closed")
                    }.bind(this);
                    o.sendMessage(n.kCommandCNXN, n.ADB_PROTOCOL_VERSION, n.MAX_PAYLOAD, "host::");
                    o.receiveMessages()
                }.bind(this));
                break;
            case "host:track-devices":
                this.tracking = c();
                this.writeDevices(function() {});
                this.tracked = Object.fromArray(Object.keys(this.server.adbDevices));
                break;
            case "host:forward":
                var l = o.join(":").substring(i.length + 1).split(";");
                var h = l[0].split(":");
                var p = parseInt(h[1]);
                var a = this.resolveTransport(e, r);
                if (a.constructor.name == "String") {
                    this.write(a, "FAIL");
                    break
                }
                a.forwardPort({
                    fromPort: p,
                    to: l[1]
                });
                this.socket.write(str2ab("OKAYOKAY"), function() {}.bind(this));
                break;
            default:
                if (this.transport) {
                    var a = this.transport;
                    a.newSocket(e, function(e) {
                        if (!e) {
                            this.socket.write(str2ab("OKAY"), function() {
                                this.socket.destroy()
                            }.bind(this));
                            return
                        }
                        this.socket.write(str2ab("OKAY"), function() {});
                        Socket.stream(e, this.socket)
                    }.bind(this));
                    return
                }
                var v = "host:transport:";
                if (e.startsWith(v)) {
                    var r = e.substr(v.length);
                    var m = this.server.adbDevices[r];
                    if (!m) {
                        this.write("device not found", "FAIL");
                        return
                    }
                    this.transport = m;
                    this.socket.write(str2ab("OKAY"), function() {});
                    break
                }
                console.log("unknown request: " + e);
                this.write("unknown command: " + e, "FAIL");
                var g = chrome.runtime.getManifest().name;
                chrome.notifications.create({
                    type: "basic",
                    iconUrl: "/icon.png",
                    title: g,
                    message: g + "'s adb server encountered an unknown adb command.\nYou may want to close " + g + " and start your adb binary manually."
                });
                break
        }
        this.receiveHeader()
    };
    a.prototype.receivePayload = function(e) {
        var t = parseInt(ab2str(e), 16);
        this.socket.read(t, this.handlePayload.bind(this))
    };
    a.prototype.receiveHeader = function() {
        this.socket.read(4, this.receivePayload.bind(this))
    };
    window.AdbDevice = n;
    window.AdbServer = s;
    window.AdbTcpTransport = t
})();
(function() {
    var e = {};
    e.sendHostCommand = function(e, t) {
        Socket.connect({
            host: "127.0.0.1",
            port: 5037
        }, function(n) {
            if (!n) {
                t();
                return
            }
            e = make4Len16(e.length) + e;
            n.read(4, function(e) {
                if (ab2str(e) != "OKAY") {
                    n.destroy();
                    t();
                    return
                }
                n.read(4, function(e) {
                    var o = ab2str(e);
                    e = parseInt(o, 16);
                    if (e == 0 || o == "OKAY") {
                        t(n, new ArrayBuffer(0));
                        return
                    }
                    n.read(e, function(e) {
                        t(n, e)
                    })
                })
            });
            n.write(str2ab(e), function() {})
        })
    };
    e.devices = function(t) {
        var n = {};

        function o(e) {
            var o = e;
            e = e.replace("	", " ");
            var i = e.indexOf(" ");
            if (i == -1) {
                t({});
                return
            }
            var r = e.substring(0, i);
            e = e.substring(i).trim();
            var s;
            while (s != e) {
                s = e;
                e = e.replace("  ", " ")
            }
            var c = {};
            var a = e.indexOf(" ");
            if (a == -1) return;
            var d = e.substring(0, a);
            e = e.substring(a + 1);
            while (e.length) {
                i = e.indexOf(":");
                if (i == -1) break;
                var u = e.substring(0, i);
                var f = e.substring(i + 1);
                var l = f.indexOf(" ");
                var h = f.indexOf(":");
                var p;
                if (l == -1 || h == -1) {
                    p = f;
                    e = ""
                } else {
                    while (l != -1 && l < h) {
                        p = f.substring(0, l);
                        e = f.substring(l + 1);
                        l = f.indexOf(" ", l + 1)
                    }
                }
                c[u] = p
            }
            var v;
            if (!c["model"]) v = r;
            else v = c["model"].replace("_", " ");
            n[r] = {
                name: v,
                status: d,
                properties: o
            }
        }
        e.sendHostCommand("host:devices-l", function(e, i) {
            if (!e) {
                t();
                return
            }
            e.destroy();
            i = ab2str(i);
            i = i.trim();
            var r = i.split("\n");
            for (var s in r) {
                s = r[s];
                o(s)
            }
            t(n)
        })
    };
    e.killServer = function(t) {
        e.sendHostCommand("host:kill-server", function(e, n) {
            if (!e) {
                t();
                return
            }
            e.destroy();
            n = ab2str(n);
            if (t) t()
        })
    };
    e.sendClientCommand = function(e, t) {
        var n = e.command;
        var o = e.serialno;
        Socket.connect({
            host: "127.0.0.1",
            port: 5037
        }, function(e) {
            if (!e) {
                t();
                return
            }
            e.read(4, function(o) {
                var i = ab2str(o);
                if (i != "OKAY") {
                    e.destroy();
                    t(null);
                    return
                }
                var r = n;
                r = make4Len16(r.length) + r;
                e.read(4, function(n) {
                    var o = ab2str(n);
                    if (o != "OKAY") {
                        e.destroy();
                        t(null);
                        return
                    }
                    t(e)
                });
                e.write(str2ab(r), function() {})
            });
            var i = "host:transport:" + o;
            i = make4Len16(i.length) + i;
            e.write(str2ab(i), function() {})
        })
    };
    e.shell = function(t, n) {
        var o = t.command;
        var i = t.serialno;
        e.getOrCreateSockFactory(t).newSocket("shell:" + o, function(e) {
            if (!e) {
                n();
                return
            }
            readString(e, function(e) {
                n(e)
            })
        })
    };
    e.forward = function(t, n) {
        var o = "host-serial:" + t.serialno + ":forward:" + t.from + ";" + t.to;
        e.sendHostCommand(o, function(e, t) {
            if (e) e.destroy();
            n(e, t)
        })
    };

    function t() {}
    t.MKID = function(e, t, n, o) {
        return e.charCodeAt(0) | t.charCodeAt(0) << 8 | n.charCodeAt(0) << 16 | o.charCodeAt(0) << 24
    };
    t.ID_RECV = t.MKID("R", "E", "C", "V");
    t.ID_SEND = t.MKID("S", "E", "N", "D");
    t.ID_DONE = t.MKID("D", "O", "N", "E");
    t.ID_DATA = t.MKID("D", "A", "T", "A");
    t.DATA_MAX = 64 * 1024;
    e.pull = function(n, o) {
        var i = n.file;
        var r = n.serialno;
        var s = n.fileEntry;
        e.getOrCreateSockFactory(n).newSocket("sync:", function(e) {
            if (!e) {
                o();
                return
            }
            s.createWriter(function(n) {
                var r = new ArrayBuffer(8);
                var c = new DataView(r);
                c.setUint32(0, t.ID_RECV, true);
                c.setUint32(4, i.length, true);
                e.write(r, function() {
                    e.write(str2ab(i), function() {
                        function i(t) {
                            e.read(t, function(e) {
                                n.write(new Blob([e]))
                            })
                        }
                        n.onwriteend = function(e) {
                            r()
                        };

                        function r() {
                            e.read(8, function(n) {
                                var r = new DataView(n.buffer, n.byteOffset, n.byteLength);
                                var c = r.getUint32(0, true);
                                if (c == t.ID_DATA) {
                                    var a = r.getUint32(4, true);
                                    i(a);
                                    return
                                }
                                e.destroy();
                                if (c == t.ID_DONE) {
                                    o(s);
                                    return
                                }
                                o()
                            })
                        }
                        r()
                    })
                })
            })
        })
    };
    e.createSocketFactory = function(t) {
        return {
            newSocket: function(n, o) {
                e.sendClientCommand({
                    serialno: t,
                    command: n
                }, o)
            }
        }
    };
    e.getOrCreateSockFactory = function(t) {
        return t.socketFactory || e.createSocketFactory(t.serialno)
    };
    e.push = function(n, o) {
        var i = n.file;
        var r = n.serialno;
        var s = n.socket;
        e.getOrCreateSockFactory(n).newSocket("sync:", function(e) {
            if (!e) {
                o();
                return
            }
            var n = new ArrayBuffer(8);
            var r = new DataView(n);
            var c = i + ",0644";
            r.setUint32(0, t.ID_SEND, true);
            r.setUint32(4, c.length, true);
            e.write(n, function() {
                e.write(str2ab(c), function() {
                    var n;
                    var i = true;
                    s.onClose = function() {
                        var n = new ArrayBuffer(8);
                        var i = new DataView(n);
                        i.setUint32(0, t.ID_DONE, true);
                        i.setUint32(4, 0, true);
                        e.write(n, function() {
                            e.read(8, function() {
                                o()
                            })
                        })
                    };

                    function r() {
                        s.read(function(e) {
                            if (e.byteLength > t.DATA_MAX) {
                                var n = e.subarray(t.DATA_MAX);
                                e = e.subarray(0, t.DATA_MAX);
                                s.unshift(n)
                            }
                            c(e)
                        })
                    }

                    function c(n) {
                        var o = new ArrayBuffer(8);
                        var i = new DataView(o);
                        i.setUint32(0, t.ID_DATA, true);
                        i.setUint32(4, n.byteLength, true);
                        e.write(o, function() {
                            var t = n.buffer;
                            if (n.byteOffset || n.length != t.byteLength) {
                                t = t.slice(n.byteOffset, n.byteOffset + n.byteLength)
                            }
                            e.write(t, function() {
                                r()
                            })
                        })
                    }
                    r()
                })
            })
        })
    };
    window.Adb = e
})();
(function() {
    function e(e, t) {
        this.transport = e;
        this.sockets = {};
        this.currentSocketId = 0;
        this.maxPayload = t || AdbDevice.MAX_PAYLOAD
    }
    e.prototype.start = function(e) {
        var t = str2ab(e, undefined, true);
        this.sendMessage(AdbDevice.kCommandCNXN, AdbDevice.ADB_PROTOCOL_VERSION, this.maxPayload, t);
        this.receiveMessages()
    };
    e.prototype.fatal = function(e) {
        console.log("fatal error", e);
        var t = this.onClose;
        if (t) {
            delete this.onClose;
            t()
        }
    };
    e.prototype.sendMessage = AdbDevice.prototype.sendMessage;
    e.prototype.receiveMessages = AdbDevice.prototype.receiveMessages;
    e.prototype.handleUnknown = AdbDevice.prototype.handleUnknown;
    e.prototype.newAdbSocket = AdbDevice.prototype.newAdbSocket;
    e.prototype.destroy = AdbDevice.prototype.destroy;
    e.prototype.onOpenSocket = function(e, t) {
        if (this.openSocket) {
            var n = ++this.currentSocketId;
            var o = this.newAdbSocket(n);
            o.remoteId = t;
            this.sockets[n] = o;
            this.sendMessage(AdbDevice.kCommandOKAY, n, t);
            this.openSocket(ab2str(e), o)
        }
    };
    window.AdbDaemon = e
})();

function verifySignature(e, t, n, o, i) {
    o = base64ToArrayBuffer(o);
    n = str2ab(n);
    window.crypto.subtle.importKey("jwk", {
        kty: "RSA",
        e: e,
        n: t,
        alg: "RS1"
    }, {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-1"
        }
    }, true, ["verify"]).then(function(e) {
        window.crypto.subtle.verify({
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-1"
            }
        }, e, o, n).then(function(e) {
            if (!e) {
                i("invalid signature");
                return
            }
            i()
        }).catch(function(e) {
            i("failure to verify", e)
        })
    }).catch(function(e) {
        i("key import failed", e)
    })
}(function() {
    function e() {
        this.licensed = true;
        this.licenseCached = true
    }
    e.prototype.refresh = function(e) {
        var t;
        var n = function() {
            if (this.isLicensed()) {
                var n = chrome.app.window.get("purchase");
                if (n != null) {
                    n.close();
                    showNotification("Vysor subscription is active. Thank you for your support!")
                }
            }
            if (t) return;
            t = true;
            if (e) e();
            if (this.globalRefresh) this.globalRefresh()
        }.bind(this);
        var o = function(e) {
            $.each(e, function(e, t) {
                console.log("subscription status", t.sku, t.state);
                if (t.state == "ACTIVE") this.licensed = true
            }.bind(this))
        }.bind(this);
        var i = false;
        var r = function(e, t) {
            if (t.sandbox != i) {
                console.log("sandbox mismatch");
                return
            }
            if (e.id != t.buyer_id) {
                console.log("id mismatch");
                return
            }
            if (t.seller_id != "koushd@gmail.com") {
                console.log("seller mismatch");
                return
            }
            $.each(t.orders, function(e, t) {
                console.log("paypal purchase status", t.is_purchased);
                if (t.is_purchased) this.licensed = true
            }.bind(this))
        }.bind(this);
        var s = function() {
            chrome.identity.getAuthToken({
                interactive: false,
                scopes: ["https://www.googleapis.com/auth/userinfo.profile"]
            }, function(e) {
                if (!e) {
                    console.log("Unable to get token for clockworkbilling");
                    n();
                    return
                }
                $.ajax({
                    url: "https://www.googleapis.com/oauth2/v1/userinfo",
                    headers: {
                        Authorization: "Bearer " + e
                    },
                    dataType: "json",
                    success: function(e) {
                        var t = e.id;
                        var o = "https://clockworkbilling.appspot.com/api/v1/purchase/koushd@gmail.com/" + t + "?sandbox=" + i + "&nonce=" + Date.now();
                        $.ajax({
                            url: o,
                            dataType: "json",
                            success: function(e) {
                                var t = JSON.parse(e.signed_data);
                                console.log("purchase data", t);
                                chrome.identity.getProfileUserInfo(function(o) {
                                    if (!o) {
                                        console.log("unable to retrieve user info for clockwork billing");
                                        n();
                                        return
                                    }
                                    r(o, t);
                                    if (!this.isLicensed()) {
                                        n();
                                        return
                                    }
                                    chrome.storage.local.set({
                                        cachedClockworkLicense: e
                                    }, function() {
                                        this.licenseCached = true;
                                        n()
                                    }.bind(this))
                                }.bind(this))
                            }.bind(this),
                            error: function(e, t) {
                                console.log("error requesting purchases");
                                n()
                            }
                        })
                    }.bind(this),
                    error: function(e, t) {
                        console.log("Unable to get buyer id for clockworkbilling");
                        n()
                    }.bind(this)
                })
            }.bind(this))
        }.bind(this);
        var c = function() {
            google.payments.inapp.getPurchases({
                parameters: {
                    env: "prod"
                },
                success: function(e) {
                    o(e.response.details);
                    if (!this.isLicensed()) {
                        s();
                        return
                    }
                    n();
                    console.log("Caching Vysor license.");
                    this.cacheLicense(function() {
                        if (this.isLicenseCached() && this.globalRefresh) this.globalRefresh()
                    }.bind(this), {
                        interactive: false
                    })
                }.bind(this),
                failure: function() {
                    console.log("failed to refresh license", arguments);
                    s()
                }.bind(this)
            })
        }.bind(this);
        var a = 4;
        var d = a / 2;
        var u = function() {
            chrome.storage.local.get("cachedLicense", function(e) {
                if (!e.cachedLicense) {
                    c();
                    return
                }
                verifySignature("AQAB", "vMGBBmLcMO4lOmg-YAHq2DjZKHTaW-xs9KPNXU_zKJ7ZhFhWH3I6skF9ZO8lKeXOSwVEIW4HVMa7m16S6WTrUw", e.cachedLicense.signed_data, e.cachedLicense.signature, function(t) {
                    if (t) {
                        console.error(t);
                        c();
                        return
                    }
                    var i = JSON.parse(e.cachedLicense.signed_data);
                    if (i.date > Date.now()) {
                        console.log("cached license date from future?");
                        c();
                        return
                    }
                    if (i.date + a * 24 * 60 * 60 * 1e3 < Date.now()) {
                        console.log("cached license is expired.");
                        c();
                        return
                    }
                    chrome.identity.getProfileUserInfo(function(e) {
                        if (!e) {
                            console.log("unable to retrieve user info");
                            c();
                            return
                        }
                        if (e.id != i.userinfo.id) {
                            console.log("id mismatch");
                            c();
                            return
                        }
                        o(i.payments);
                        if (!this.isLicensed()) {
                            c();
                            return
                        }
                        console.log("cached license is valid for " + (i.date + a * 24 * 60 * 60 * 1e3 - Date.now()) / (60 * 60 * 1e3) + " hours");
                        this.licenseCached = true;
                        n();
                        if (i.date + d * 24 * 60 * 60 * 1e3 < Date.now()) c()
                    }.bind(this))
                }.bind(this))
            }.bind(this))
        }.bind(this);
        chrome.storage.local.get("cachedClockworkLicense", function(e) {
            if (!e.cachedClockworkLicense) {
                u();
                return
            }
            verifySignature("AQAB", "vMGBBmLcMO4lOmg-YAHq2DjZKHTaW-xs9KPNXU_zKJ7ZhFhWH3I6skF9ZO8lKeXOSwVEIW4HVMa7m16S6WTrUw", e.cachedClockworkLicense.signed_data, e.cachedClockworkLicense.signature, function(t) {
                if (t) {
                    console.error(t);
                    u();
                    return
                }
                var o = JSON.parse(e.cachedClockworkLicense.signed_data);
                if (o.timestamp + a * 24 * 60 * 60 * 1e3 < Date.now()) {
                    console.log("cached license is expired.");
                    u();
                    return
                }
                if (o.timestamp > Date.now()) {
                    console.log("cached license date from future?");
                    u();
                    return
                }
                chrome.identity.getProfileUserInfo(function(e) {
                    if (!e) {
                        console.log("unable to retrieve user info");
                        u();
                        return
                    }
                    r(e, o);
                    if (!this.isLicensed()) {
                        u();
                        return
                    }
                    console.log("cached clockwork license is valid for " + (o.timestamp + a * 24 * 60 * 60 * 1e3 - Date.now()) / (60 * 60 * 1e3) + " hours");
                    this.licenseCached = true;
                    n();
                    if (o.timestamp + d * 24 * 60 * 60 * 1e3 < Date.now()) s()
                }.bind(this))
            }.bind(this))
        }.bind(this))
    };
    e.prototype.cacheLicense = function(e, t) {
        if (!t) {
            t = {
                interactive: true
            }
        }
        chrome.identity.getAuthToken(t, function(n) {
            if (!n) {
                if (t.interactive) showNotification("Unable to get auth token.");
                return
            }
            $.ajax({
                type: "post",
                url: "https://clockworkbilling.appspot.com/api/v1/verify/google/koushd@gmail.com",
                data: {
                    token: n,
                    item: chrome.runtime.id
                },
                dataType: "json",
                success: function(t) {
                    this.licenseCached = true;
                    chrome.storage.local.set({
                        cachedLicense: t
                    }, e)
                }.bind(this),
                error: function(t, n) {
                    if (e) e(n)
                }
            })
        }.bind(this))
    };
    e.prototype.isLicensed = function() {
        return this.licensed
    };
    e.prototype.isLicenseCached = function() {
        return this.licenseCached
    };
    e.prototype.startPurchase = function() {
        chrome.app.window.create("purchase.html", {
            id: "purchase",
            resizable: false,
            bounds: {
                width: 800,
                height: 800
            }
        }, function(e) {
            this.refresh();
            e.contentWindow.refreshLicenseManager = function() {
                this.refresh()
            }.bind(this)
        }.bind(this))
    };
    window.LicenseManager = e
})();

function GcmDevice(e, t, n) {
    this.adbSocketFactory = e;
    this.conn = n;
    this.conn.openSocket = this.openSocket.bind(this);
    var o = t.properties.substring(t.properties.indexOf("product")).replace(/ /g, ";").replace("device", "ro.product.device").replace("model", "ro.product.model").replace("product", "ro.product.name").replace(/:/g, "=");
    this.properties = "device::" + o + ";"
}
GcmDevice.prototype.openSocket = function(e, t) {
    if (this.onOpenSocket && this.onOpenSocket(e, t)) return;
    if (e == "properties") {
        var n = this.properties;
        t.write(str2ab(n), function() {
            console.log("sent properties", n);
            t.destroy()
        });
        return
    }
    this.adbSocketFactory.newSocket(e, function(n) {
        if (!n) {
            console.log("unable to execute adb proxy command?", e);
            t.destroy();
            return
        }
        Socket.stream(n, t, function() {})
    })
};

function getWhitelist(e) {
    chrome.storage.local.get("whitelist", function(t) {
        var n = {};
        if (!t.whitelist || t.whitelist.constructor.name != "Array") {
            e(n);
            return
        }
        $.each(t.whitelist, function(e, t) {
            n[t] = true
        });
        e(n)
    })
}

function saveWhitelist(e, t) {
    chrome.storage.local.set({
        whitelist: Object.keys(e)
    }, t)
}

function addToWhitelist(e, t) {
    getWhitelist(function(n) {
        n[e] = true;
        saveWhitelist(n, t)
    })
}

function clearWhitelist() {
    chrome.storage.local.remove("whitelist")
}(function() {
    var e = new AdbServer({
        start: false
    });
    var t;
    var n;
    var o = {};
    var i = {};
    var r = {};
    var s;
    var c = analytics.getService("vysor_app");
    var a = c.getTracker("UA-4956323-6");
    var d = new LicenseManager;
    d.globalRefresh = function() {
        l();
        u()
    };
    d.refresh();

    function u() {
        if (!d.isLicensed() || !s) return;
        $(s.contentWindow.document).find("#purchase").hide();
        if (d.isLicenseCached()) $(s.contentWindow.document).find("#login-container").hide();
        else $(s.contentWindow.document).find("#login-container").show()
    }
    var f = "software";

    function l() {
        if (!d.isLicensed()) return;
        if (!s) return;
        chrome.storage.local.get("bitrate", function(e) {
            var t = $(s.contentWindow.document).find("#bitrate")[0];
            if (!t) return;
            t.selectedIndex = e.bitrate
        })
    }

    function h() {
        if (!s) return;
        if (!n) {
            $(s.contentWindow.document).find("#vysor-share-server-status").hide();
            $(s.contentWindow.document).find("#whitelist-count").hide()
        } else {
            $(s.contentWindow.document).find("#whitelist-count").show();
            getWhitelist(function(e) {
                $(s.contentWindow.document).find("#whitelist-count a").text(Object.keys(e).length + " user(s) can access this server.").click(function(e) {
                    chrome.app.window.create("whitelist.html", {
                        id: "whitelist",
                        innerBounds: {
                            width: 768,
                            height: 512,
                            minWidth: 768,
                            minHeight: 512
                        }
                    }, function(e) {
                        e.onClosed.addListener(function() {
                            h()
                        })
                    })
                })
            });
            $(s.contentWindow.document).find("#vysor-share-server-status").show();
            $(s.contentWindow.document).find("#vysor-share-server-status").html("Vysor is sharing your devices: " + '<a href="#">' + n + "</a>");
            var e = $(s.contentWindow.document).find("#vysor-share-server-status a");
            e.click(function() {
                copyTextToClipboard(n);
                var e = chrome.runtime.getManifest().name;
                showNotification("Copied " + e + " share URL to clipboard.");
                chrome.browser.openTab({
                    url: "http://www.vysor.io/share#" + n
                })
            })
        }
    }

    function p(e, t, n) {
        return function() {
            if (!d.isLicensed()) {
                showNotification("The " + e + " feature is only avaiable to Vysor Pro users.");
                d.startPurchase();
                if (n) n.apply(this, arguments);
                return
            }
            t.apply(this, arguments)
        }
    }

    function v(e, t) {
        if (!d.isLicensed()) {
            showNotification("The " + e + " feature is only avaiable to Vysor Pro users.");
            d.startPurchase();
            return
        }
        t()
    }
    var m;
    chrome.storage.local.get("vysorForceSocket", function(e) {
        m = e.vysorForceSocket
    });

    function g(e, t) {
        var n = chrome.app.window.get(e);
        if (!n) return;
        $(n.contentWindow.document).find("#loading-text").html(t)
    }

    function y(e, t) {
        g(e, "Installing Vysor APK...");
        $.ajax({
            url: "/Vysor-release.apk",
            dataType: "binary",
            responseType: "arraybuffer",
            success: function(n) {
                var o = new Uint8Array(n);
                var i = new DummySocket(o);
                var r = "/data/local/tmp/vysor" + (new Date).getTime() + ".apk";
                Adb.push({
                    serialno: e,
                    file: r,
                    socket: i
                }, function() {
                    Adb.shell({
                        command: "pm install -r " + r,
                        serialno: e
                    }, t)
                })
            }
        })
    }

    function b(e, n, o) {
        g(e, "Connecting...");

        function i(i) {
            var r = Math.round(Math.random() * (1 << 30)).toString(16);
            var s = "echo -n " + r + " > /data/local/tmp/vysor.pwd ; chmod 600 /data/local/tmp/vysor.pwd";
            Adb.shell({
                command: "ls -l /system/bin/app_process*",
                serialno: e
            }, function(c) {
                var a = "/system/bin/app_process";
                if (c && c.indexOf("app_process32") != -1) {
                    a += "32"
                }
                Adb.sendClientCommand({
                    command: 'shell:sh -c "CLASSPATH=' + i + " " + a + " /system/bin com.koushikdutta.vysor.Main password=" + r + " keyboard=" + t + '"',
                    serialno: e
                }, function(t) {
                    Adb.shell({
                        serialno: e,
                        command: 'sh -c "' + s + '"'
                    }, function(e) {
                        Socket.eat(t);
                        o(n, r)
                    })
                })
            })
        }

        function r(t) {
            g(e, "Connecting...");
            Adb.shell({
                command: "pm path com.koushikdutta.vysor",
                serialno: e
            }, function(n) {
                if (n == "" || !n) {
                    t(null);
                    return
                }
                var o = n.match(/package:\/.*?[\r\n]/);
                if (!o || !o.length) {
                    t(null);
                    return
                }
                n = o[0];
                n = n.replace("package:", "").trim();
                Adb.shell({
                    command: 'sh -c "CLASSPATH=' + n + ' /system/bin/app_process /system/bin com.koushikdutta.vysor.ProtocolVersionMain"',
                    serialno: e
                }, function(e) {
                    var o = e.match(/vysor-io-.*?[\r\n]/);
                    if (!o || !o.length) {
                        t(null);
                        return
                    }
                    e = o[0];
                    if (e) e = e.trim();
                    console.log("protocol version: " + e);
                    if (e != "vysor-io-23") t(null);
                    else t(n)
                })
            })
        }
        r(function(t) {
            if (!t) {
                console.log("installing apk");
                y(e, function(t) {
                    r(function(n) {
                        if (!n) {
                            if (!t) t = "";
                            showNotification("Error installing APK:\n" + t.trim());
                            w(e);
                            return
                        }
                        i(n)
                    })
                });
                return
            }
            i(t)
        })
    }

    function w(e) {
        var t = chrome.app.window.get(e);
        if (t) t.close()
    }
    var k = 53516;

    function S(e, t) {
        var n = k++;
        Adb.forward({
            from: "tcp:" + n,
            to: "tcp:53516",
            serialno: e
        }, function() {
            b(e, n, t)
        })
    }

    function C(t, n, i, r) {
        if (o[n]) {
            console.log("vysor socket fast path");
            t.contentWindow.adbSocketFactory = o[n]
        } else if (e.isRunning()) {
            console.log("adb server socket path");
            t.contentWindow.adbSocketFactory = e.adbDevices[n]
        } else {
            console.log("adb client socket path");
            t.contentWindow.adbSocketFactory = Adb.createSocketFactory(n)
        }
        t.contentWindow.openList = R;
        t.contentWindow.port = i;
        t.contentWindow.password = r;
        t.contentWindow.serialno = n;
        t.contentWindow.tracker = a;
        t.contentWindow.acceleration = f;
        t.contentWindow.Function.prototype.libind = function(e, t) {
            return function() {
                if (!d.isLicensed()) {
                    showNotification("The " + e + " is only avaiable to Vysor Pro users.");
                    d.startPurchase();
                    return
                }
                this.apply(t, arguments)
            }.bind(this)
        }
    }

    function A() {
        setTimeout(function() {
            if (!chrome.app.window.getAll().length) {
                chrome.runtime.reload()
            }
        }, 5e3)
    }

    function D(e, t) {
        P();
        var n = chrome.app.window.get(e);
        if (n) {
            n.show();
            if (t) {
                S(e, function(t, o) {
                    C(n, e, t, o);
                    n.contentWindow.connectionReady()
                })
            }
            return
        }
        chrome.app.window.create("screen.html", {
            id: e,
            bounds: {
                width: 576,
                height: 1024
            }
        }, function(t) {
            var n;
            t.onClosed.addListener(n = function() {
                t.onClosed.removeListener(n);
                A();
                if (t.contentWindow.h264Socket) {
                    console.log("cleaning up h264 socket");
                    t.contentWindow.h264Socket.destroy();
                    t.contentWindow.h264Socket = null
                }
                if (t.contentWindow.inputWebSocket) {
                    console.log("cleaning up input websocket");
                    t.contentWindow.inputWebSocket.close();
                    t.contentWindow.inputWebSocket = null
                }
            });
            t.contentWindow.onload = function() {
                C(t, e, null, null);
                t.contentWindow.docReady();
                if (!K[e]) {
                    console.log("Vysor requested for", e, "which is not available yet");
                    return
                }
                S(e, function(n, o) {
                    C(t, e, n, o);
                    t.contentWindow.connectionReady();
                    Adb.shell({
                        command: "am start com.koushikdutta.vysor/.TipsActivity",
                        serialno: e
                    }, function() {})
                })
            }
        })
    }

    function L(e) {
        var t = [5e5, 75e4, 1e6, 15e5, 2e6];
        var n = t[e];
        var o = chrome.app.window.getAll();
        for (var i in o) {
            i = o[i];
            if (!i.contentWindow.sendEvent) {
                console.log(i.id, "not a device window");
                continue
            }
            console.log(i.id, "updating device window");
            i.contentWindow.sendEvent({
                type: "bitrate",
                bitrate: n
            })
        }
    }

    function W() {
        n = null;
        M.stopListen("share");
        h()
    }

    function I(e, t, n) {
        if (!e.devices[t]) return;
        if (e.gcmConn.gcmConns[t]) e.gcmConn.gcmConns[t].destroy();
        var o;
        var i = e.gcmConn.gcmConns[t] = {
            farm: true,
            newSocket: function(n, i) {
                if (o) return;
                e.gcmConn.newSocket(t + ":" + n, i)
            },
            destroy: function() {
                o = true;
                if (e.gcmConn.gcmConns[t] == i) delete e.gcmConn.gcmConns[t];
                e.gcmConn.newSocket("close:" + t, function(e) {
                    e.destroy()
                });
                var n = i.onClose;
                if (n) {
                    delete i.onClose;
                    n()
                }
            }
        };
        U(function(e) {
            e(i)
        }, n)
    }

    function O(e, t) {
        e = new URL(e);
        var n = e.hash.replace("#", "");

        function o(e) {
            M.connect(e.registration, "share", function(o) {
                var i = r[n];
                if (i) {
                    clearTimeout(i.refresher);
                    i.gcmConn.destroy()
                }
                var s = r[n] = {
                    info: e,
                    gcmConn: o
                };
                o.gcmConns = {};
                o.openSocket = function(e, n) {
                    if (e.startsWith("challenge:")) {
                        console.log("received challenge", e);
                        var i = e.split(":")[1];
                        $.ajax({
                            type: "post",
                            url: "https://vysor-1026.appspot.com/verifyauth",
                            headers: {
                                Authorization: "Bearer " + t
                            },
                            data: {
                                nonce: i
                            },
                            dataType: "json",
                            success: function(e) {
                                console.log("sending challenge response", e);
                                writeLine(n, e, function() {
                                    readLine(n, function(e) {
                                        if (e == "ok") c();
                                        n.destroy()
                                    })
                                })
                            },
                            error: function(e, t) {
                                showNotification("Unable to verify identity");
                                n.destroy()
                            }
                        })
                    } else if (e.startsWith("close:")) {
                        n.destroy();
                        var r = e.split(":")[1];
                        var s = o.gcmConns[r];
                        if (!s) {
                            console.log("can't close unknown subconn");
                            return
                        }
                        s.destroy()
                    } else {
                        console.log("got unknown socket request", e);
                        n.destroy()
                    }
                };
                o.onClose = function() {
                    clearTimeout(s.refresher);
                    if (r[n] == s) delete r[n];
                    $.each(Object.keys(o.gcmConns), function(e, t) {
                        var n = o.gcmConns[t];
                        if (n) n.destroy()
                    })
                };

                function c() {
                    o.newSocket("devices:", function(e) {
                        readString(e, function(e) {
                            clearTimeout(s.refresher);
                            s.refresher = setTimeout(c, 1e3);
                            var t = JSON.parse(e);
                            var n = t.devices;
                            var i = t.sharedDevices;
                            if (!s.devices) {
                                s.devices = n
                            } else {
                                $.each(Object.keys(n), function(e, t) {
                                    delete s.devices[t]
                                });
                                $.each(Object.keys(s.devices), function(e, t) {
                                    var n = o.gcmConns[t];
                                    if (n) n.destroy()
                                });
                                s.devices = n;
                                s.sharedDevices = i
                            }
                        })
                    })
                }
                console.log("Connection to device farm established", o)
            })
        }
        $.ajax({
            url: "https://vysor-1026.appspot.com/gcm/" + n,
            dataType: "json",
            success: o,
            error: function(e, t) {
                showNotification("Unable to find server: " + t)
            }
        })
    }

    function T() {
        W();
        chrome.identity.getAuthToken({
            interactive: true,
            scopes: ["https://www.googleapis.com/auth/userinfo.profile"]
        }, function(e) {
            if (!e) {
                showNotification("Unable to get auth token");
                $(s.contentWindow.document).find("#share-all-check").prop("checked", falseAuto);
                return
            }
            $.ajax({
                type: "post",
                url: "https://vysor-1026.appspot.com/gcm",
                headers: {
                    Authorization: "Bearer " + e
                },
                data: {
                    registration: M.registrationId
                },
                dataType: "json",
                success: function(e) {
                    console.log(e);
                    n = "https://vysor.clockworkmod.com/server#" + e.id;
                    h()
                }.bind(this),
                error: function(e, t) {
                    showNotification("Unable to register server: " + t);
                    W()
                }
            });
            M.listen("share", function(e) {
                var t;
                var n;
                var r;
                var s = {};
                var c = Math.round(Math.random() * (1 << 30)).toString(16) + Math.round(Math.random() * (1 << 30)).toString(16);
                e.onClose = function() {
                    $.each(Object.keys(s), function(e, t) {
                        var n = s[t];
                        n.destroy()
                    })
                };
                e.newSocket("challenge:" + c, function(e) {
                    readLine(e, function(o) {
                        console.log("received challenge response", o);
                        var i = JSON.parse(o);

                        function s() {
                            writeLine(e, "fail", function() {
                                e.destroy()
                            })
                        }
                        verifySignature("AQAB", "hDuGsIhbjLYXteQX3F3KNriQHwUSZurS5voCkdpA1733A65pqtGOrk9g_yLiF94_vSK0VmL-4stq7WAYEbn6nw", i.signed_data, i.signature, function(o) {
                            if (o) {
                                console.log("Remote user failed to authorize", o);
                                s();
                                return
                            }
                            n = JSON.parse(i.signed_data);
                            if (n.nonce != c) {
                                console.log("Remote user failed to authorize, mismatched nonce");
                                s();
                                return
                            }

                            function a() {
                                function o() {
                                    t = true;
                                    writeLine(e, "ok", function() {
                                        e.destroy()
                                    });
                                    showNotification("Vysor is sharing Android devices with " + n.name, r);
                                    addToWhitelist(n.email, function() {
                                        h()
                                    })
                                }
                                getWhitelist(function(e) {
                                    if (e[n.email]) {
                                        o();
                                        return
                                    }
                                    var t = chrome.runtime.getManifest().name;
                                    chrome.notifications.create({
                                        type: "basic",
                                        iconUrl: r,
                                        title: t,
                                        message: n.name + " is requesting access to Vysor shared Android devices.",
                                        buttons: [{
                                            title: "Allow"
                                        }, {
                                            title: "Deny"
                                        }]
                                    }, function(e) {
                                        var t;
                                        var n = function(o) {
                                            if (o != e) return;
                                            chrome.notifications.onClosed.removeListener(n);
                                            chrome.notifications.onButtonClicked.removeListener(i);
                                            if (!t) s()
                                        };
                                        var i = function(n, i) {
                                            if (n != e) return;
                                            chrome.notifications.clear(n);
                                            t = true;
                                            if (i == 0) o();
                                            else s()
                                        };
                                        chrome.notifications.onClosed.addListener(n);
                                        chrome.notifications.onButtonClicked.addListener(i)
                                    })
                                })
                            }
                            if (n.picture) {
                                blobFromUrl(n.picture, function(e) {
                                    r = e;
                                    a()
                                })
                            } else {
                                r = "/icon.png";
                                a()
                            }
                        })
                    })
                });
                e.openSocket = function(r, c) {
                    if (!t) {
                        c.destroy();
                        return
                    }
                    if (r == "devices:") {
                        var a = {};
                        $.each(Object.keys(K), function(e, t) {
                            if (!o[t]) a[t] = K[t]
                        });
                        var d = {};
                        $.each(Object.keys(i), function(e, t) {
                            d[t] = {
                                userInfo: i[t].userInfo
                            }
                        });
                        writeString(c, {
                            devices: a,
                            sharedDevices: d
                        }, function() {
                            c.destroy()
                        })
                    } else if (r.startsWith("close:")) {
                        c.destroy();
                        var u = r.split(":")[1];
                        var f = s[u];
                        if (f) f.destroy()
                    } else {
                        var l = r.indexOf(":");
                        if (l == -1) {
                            console.log("unexpected command received by device farm server");
                            c.destroy();
                            return
                        }
                        var u = r.substring(0, l);
                        if (!K[u]) {
                            c.destroy();
                            return
                        }
                        var f = s[u];
                        if (!f) {
                            var h = Adb.createSocketFactory(u);
                            f = s[u] = new GcmDevice(h, K[u], {});
                            f.destroy = function() {
                                try {
                                    e.newSocket("close:" + u, function(e) {
                                        e.destroy()
                                    })
                                } catch (t) {}
                                var o = i[u];
                                if (o) {
                                    if (o.userInfo == n) delete o.userInfo;
                                    if (o.gcmConn == this) delete o.gcmConn;
                                    if (!o.key) delete i[u]
                                }
                                var r = this.onClose;
                                if (r) {
                                    delete this.onClose;
                                    r()
                                }
                            }.bind(f)
                        }
                        var p = i[u];
                        if (!p) p = i[u] = {};
                        if (p.gcmConn != f) {
                            x(u);
                            p.gcmConn = f;
                            p.userInfo = n
                        }
                        var v = r.substring(l + 1);
                        f.openSocket(v, c)
                    }
                }
            })
        })
    }

    function R(n) {
        if (s) {
            if (n) {
                n(s)
            }
            return
        }
        chrome.app.window.create("list.html", {
            id: "list",
            innerBounds: {
                width: 768,
                height: 768,
                minWidth: 768,
                minHeight: 768
            }
        }, function(o) {
            s = o;
            s.contentWindow.onload = function() {
                if (navigator.platform.toLowerCase().indexOf("win") == -1) {
                    $(s.contentWindow.document).find("#windows").hide()
                }
                s.contentWindow.adbServer = e;
                s.contentWindow.tracker = a;
                chrome.storage.local.get("connect-automatically", function(e) {
                    var t = e["connect-automatically"] !== false;
                    $(s.contentWindow.document).find("#connect-automatically-check").prop("checked", t)
                });
                $(s.contentWindow.document).find("#bitrate").change(p("Image Quality", function() {
                    L(this.selectedIndex);
                    chrome.storage.local.set({
                        bitrate: this.selectedIndex
                    })
                }, function() {
                    this.selectedIndex = 0
                }));
                $(s.contentWindow.document).find("#connect-automatically-check").change(function() {
                    chrome.storage.local.set({
                        "connect-automatically": this.checked
                    })
                });
                $(s.contentWindow.document).find("#share-all-check").change(p("Vysor Share", function() {
                    if (this.checked) T();
                    else W()
                }, function() {
                    this.checked = false
                }));
                $(s.contentWindow.document).find("#vysor-keyboard-check").change(function() {
                    t = this.checked;
                    chrome.storage.local.set({
                        keyboard: this.checked
                    })
                });
                chrome.storage.local.get("keyboard", function(e) {
                    t = e.keyboard !== false;
                    $(s.contentWindow.document).find("#vysor-keyboard-check").prop("checked", t)
                });
                $(s.contentWindow.document).find("#share-all-check").prop("checked", M.isListening("share"));
                $(s.contentWindow.document).find("#connect-android").hide();
                $(s.contentWindow.document).find("#purchase").click(function() {
                    d.startPurchase()
                });
                $(s.contentWindow.document).find("#login").click(function() {
                    $(s.contentWindow.document).find("#login-line").hide();
                    $(s.contentWindow.document).find("#logging-in").show();
                    d.cacheLicense(function(e) {
                        if (e) {
                            showNotification("Error saving license for offline use: " + e);
                            $(s.contentWindow.document).find("#login-line").show();
                            $(s.contentWindow.document).find("#logging-in").hide();
                            return
                        }
                        $(s.contentWindow.document).find("#logging-in").hide();
                        showNotification("License was saved for offline use. Thanks!")
                    })
                });
                u();
                l();
                h()
            };
            s.onClosed.addListener(function() {
                s = null;
                A()
            });
            if (n) {
                controller = new Controller(receiverWindow.contentWindow, true);
                n(receiverWindow)
            }
        })
    }

    function U(t, n) {
        e.start();
        var i = new Server;
        i.listen({
            port: 0,
            address: "127.0.0.1"
        }, function(e) {
            i.destroy();
            var r = new AdbDaemon(new AdbTcpTransport(e));
            t(function(e) {
                a.sendEvent("connected-shared-device");
                var t = "127.0.0.1:" + i.localPort;
                e.serialno = t;
                o[t] = e;
                console.log("connected gcm socket");
                e.openSocket = function() {
                    console.log("got a new socket? this should not happen...");
                    e.destroy()
                };
                r.onClose = e.onClose = function() {
                    delete o[t];
                    r.destroy();
                    e.destroy()
                };
                e.onClose = function() {
                    delete o[t];
                    r.destroy();
                    e.destroy();
                    showNotification("Disconnected from shared Android device.")
                };
                r.openSocket = function(t, n) {
                    e.newSocket(t, function(e) {
                        Socket.stream(n, e, function() {})
                    })
                };
                e.newSocket("properties", function(e) {
                    readString(e, function(e) {
                        r.start(e);
                        console.log("got properties", e);
                        n(t)
                    })
                })
            })
        }.bind(this), function(e) {
            if (e) {
                console.log("adb daemon failed to listen: " + e);
                return
            }
            Adb.sendHostCommand("host:connect:127.0.0.1:" + i.localPort, function(e, t) {
                if (!e) {
                    return
                }
                e.destroy();
                t = ab2str(t);
                console.log("adb connect result", t)
            })
        }.bind(this))
    }

    function N(e, t) {
        showNotification("Vysor is connecting to a remote Android device");
        if (s) s.show();
        console.log("attempting to connect to shared device", e);
        if (!M) {
            console.log("gcm not ready.");
            return
        }
        var n;
        var o;
        var i = new URL(e);
        if (!(n = getQueryVariable("registrationId", i)) || !(o = getQueryVariable("channel", i))) {
            var r = i.pathname.split("/");
            n = r[2];
            o = r[3]
        }
        U(function(e) {
            M.connect(n, o, e)
        }, t)
    }
    chrome.app.runtime.onLaunched.addListener(function(e) {
        R();
        if (e && e.id == "vysor_purchase") {
            d.refresh();
            return
        }
        if (e && e.id == "vysor_presentation") {
            N(e.url, function(e) {
                D(e)
            });
            return
        }
        if (e && e.id == "vysor_device_farm") {
            console.log("device farm", e.url);
            if (s) s.show();
            R();
            showNotification("Vysor is connecting to shared Android devices");
            chrome.identity.getAuthToken({
                interactive: true,
                scopes: ["https://www.googleapis.com/auth/userinfo.profile", "https://www.googleapis.com/auth/userinfo.email"]
            }, function(t) {
                if (!t) {
                    showNotification("Unable to get auth token");
                    return
                }
                O(e.url, t)
            })
        }
        P()
    });

    function P() {
        chrome.runtime.requestUpdateCheck(function(e, t) {
            if (e == "update_available") {
                q()
            }
        })
    }
    var M;
    GcmRtcManager.start("64148182473", "AIzaSyDd7k1v017osyYbIC92fyf-36s3pv0z73U", {
        iceServers: [{
            url: "turn:n0.clockworkmod.com",
            username: "foo",
            credential: "bar"
        }, {
            url: "turn:n1.clockworkmod.com",
            username: "foo",
            credential: "bar"
        }]
    }, function(e) {
        M = e
    });

    function x(e) {
        var t = i[e];
        if (t && t.gcmConn) {
            var n = t.gcmConn;
            delete t.gcmConn;
            n.destroy()
        }
    }

    function _(e) {
        x(e);
        delete i[e]
    }

    function E(e, t) {
        var n = Math.round(Math.random() * (1 << 30)).toString(16);
        if (!i[e]) i[e] = {};
        i[e].key = n;
        var o = "https://vysor.clockworkmod.com/redirect/" + encodeURIComponent(M.registrationId) + "/" + n;
        o = "https://vysor.clockworkmod.com/app/vysor?registrationId=" + encodeURIComponent(M.registrationId) + "&channel=" + n;
        o = "https://vysor.clockworkmod.com/redirect/?registrationId=" + encodeURIComponent(M.registrationId) + "&channel=" + n;
        console.log(o);
        M.listen(n, function(o) {
            a.sendEvent("shared-device");
            var r = i[e];
            if (!r || r.key != n) {
                o.destroy();
                console.log("device is no longer being shared.");
                return
            }
            if (r.gcmConn) r.gcmConn.destroy();
            r.gcmConn = o;
            r.userInfo = {
                name: "Someone"
            };
            console.log("accepted gcm socket");
            var s = Adb.createSocketFactory(e);
            var c = new GcmDevice(s, t, o);
            c.onOpenSocket = function(t, n) {
                if (t == "webstart") {
                    b(e, null, function(t, o) {
                        writeLine(n, o, function() {
                            console.log("sent password", o);
                            n.destroy()
                        });
                        Adb.shell({
                            command: "am start com.koushikdutta.vysor/.TipsActivity",
                            serialno: e
                        }, function() {})
                    });
                    return true
                }
            }
        });
        copyTextToClipboard(o);
        var r = chrome.runtime.getManifest().name;
        showNotification("Copied " + r + " share URL to clipboard.");
        chrome.browser.openTab({
            url: "http://www.vysor.io/share#" + o
        })
    }
    var F = {};
    var B = {};
    var K = {};
    var V;

    function j() {
        if (!s) {
            return
        }
        $.each($(s.contentWindow.document).find(".local-device"), function(e, t) {
            if (!K[t.name]) $(t).remove()
        });
        $(s.contentWindow.document).find("#farms-list").empty();
        var t = Object.keys(K);
        var n = Object.keys(r);
        if (!t.length) {
            var c = $(s.contentWindow.document).find("#devices").find("#no-local-devices");
            if (!c.length) {
                c = $('<a id="no-local-devices" href="https://www.youtube.com/watch?v=Ucs34BkfPB0&feature=youtu.be"><div class="alert alert-danger">No devices found. Make sure Android USB Debugging is enabled.</div></a>');
                $(s.contentWindow.document).find("#devices").append(c)
            }
            if (!V || e.isRunning()) {
                $(s.contentWindow.document).find("#choose-header").hide();
                c.hide()
            }
        } else {
            $(s.contentWindow.document).find("#no-local-devices").remove();
            $(s.contentWindow.document).find("#choose-header").show();
            $(t).each(function(e, t) {
                if (o[t] && o[t].farm) return;
                var n = K[t];
                var r = n.name;
                var c = r;
                if (n.status == "unauthorized") c = "Unauthorized";
                var d = $(s.contentWindow.document).find("#devices").find('.local-device[name="' + t + '"]');
                if (!d.length) {
                    d = $('<a class="list-group-item local-device"><button type="button" class="btn btn-sm wireless btn-default"><i class="fa fa-wifi" title="Go Wireless"></i></button><button type="button" class="btn btn-sm share btn-default">Share</button><button type="button" class="btn btn-sm btn-success">View</button><img class="avatar img-rounded"></img><h5 class="list-group-item-heading" id="display"></h5><p class="list-group-item-text" id="serialno"></p></a>');
                    d[0].name = t;
                    var u = d.find(".share");
                    var f = d.find("img");
                    f.click(function(e) {
                        e.stopPropagation();
                        var n = i[t].userInfo;
                        blobFromUrl(n.picture, function(e) {
                            showNotification("Device in use by " + n.name, e)
                        })
                    });
                    d.find(".wireless").click(p("Go Wireless", function(e) {
                        e.stopPropagation();
                        var n = Adb.createSocketFactory(t);
                        n.newSocket("shell:ifconfig wlan0", function(e) {
                            if (!e) {
                                console.log("error running tcpip:5555");
                                return
                            }
                            readString(e, function(e) {
                                console.log("ifconfig result", e);
                                var o = e.match("inet addr:(.*?) ");
                                if (!o) {
                                    showNotification("Unable to switch to wireless mode. Is your Android connected to Wifi?");
                                    return
                                }
                                var i = o[1];
                                var r = i + ":5555";

                                function s() {
                                    F[t] = r;
                                    B[r] = t;
                                    w(t);
                                    D(r, true);
                                    showNotification("Vysor is connected wirelessly. You may disconnect your device.")
                                }
                                if (K[r]) {
                                    s();
                                    return
                                }
                                n.newSocket("tcpip:5555", function(e) {
                                    if (!e) {
                                        showNotification("Failure while switching to wireless mode.");
                                        return
                                    }
                                    readString(e, function(e) {
                                        console.log("tcpip:5555 result", e);
                                        Adb.sendHostCommand("host:connect:" + r, function(e, t) {
                                            if (!e) {
                                                return
                                            }
                                            e.destroy();
                                            t = ab2str(t);
                                            console.log("adb connect result", t);
                                            s()
                                        })
                                    })
                                })
                            })
                        })
                    }, function(e) {
                        e.stopPropagation()
                    }));
                    if (o[t]) {
                        u.text("Disconnect Shared Device");
                        u.click(function(e) {
                            e.stopPropagation();
                            var n = o[t];
                            if (n) n.destroy()
                        })
                    } else {
                        u.click(p("Vysor Share", function(e) {
                            e.stopPropagation();
                            if (i[t]) {
                                u.text("Share");
                                _(t)
                            } else {
                                u.text("Unshare");
                                E(t, n)
                            }
                        }, function(e) {
                            e.stopPropagation()
                        }))
                    }
                    d.click(function() {
                        var e = K[t];
                        if (e.status == "unauthorized") {
                            showNotification('Check your Android device and click "Allow USB Debugging".')
                        } else {
                            a.sendEvent("click-device", r);
                            D(t)
                        }
                    });
                    $(s.contentWindow.document).find("#devices").append(d)
                }
                var l = B[t];
                if (l && K[l]) d.hide();
                else d.show();
                var u = d.find(".share");
                var f = d.find("img");
                if (t.indexOf(":") != -1) d.find(".wireless").hide();
                else d.find(".wireless").show();
                d.find("#display").text(c);
                d.find("#serialno").text("Serial: " + t);
                if (i[t] && i[t].userInfo && i[t].userInfo.picture) {
                    var h = i[t].userInfo;
                    f.attr("alt", "Device in use by " + h.name);
                    blobFromUrl(h.picture, function(e) {
                        f.attr("src", e)
                    });
                    f.show()
                } else {
                    f.hide()
                }
                if (i[t]) u.text("Unshare");
                if (!M) u.hide();
                else u.show()
            })
        }
        $(n).each(function(e, t) {
            var n = t;
            t = r[t];
            if (!t.devices) return;
            var o = Object.keys(t.devices);
            if (!o.length) return;
            var i = $("<h5 class='list-header'>" + t.info.name + "'s Shared Devices <button class='btn btn-danger btn-xs' style='float: right;' type='button'>Disconnect</button></h5>");
            i.find("button").click(function() {
                t.gcmConn.destroy()
            });
            $(s.contentWindow.document).find("#farms-list").append(i);
            i = $("<div id='farm-" + n + "' class='list-group'></div>");
            $(s.contentWindow.document).find("#farms-list").append(i);
            $(o).each(function(e, n) {
                var o = t.devices[n];
                var r = o.name;
                var s = r;
                var c;
                if (t.gcmConn.gcmConns[n]) c = "Serial: " + t.gcmConn.gcmConns[n].serialno;
                else c = "Remote Serial: " + n;
                var a = $('<a class="list-group-item"><button type="button" class="btn btn-sm connect">Connect</button><button type="button" class="btn btn-sm btn-success">View</button><img class="avatar img-rounded"></img><h5 class="list-group-item-heading">' + s + '</h5><p class="list-group-item-text">' + c + "</p></a>");
                var d = a.find("img");
                if (t.sharedDevices && t.sharedDevices[n] && t.sharedDevices[n].userInfo) {
                    var u = t.sharedDevices[n].userInfo;
                    d.attr("alt", "Device in use by " + u.name);
                    blobFromUrl(u.picture, function(e) {
                        d.attr("src", e)
                    });
                    d.click(function(e) {
                        e.stopPropagation();
                        blobFromUrl(u.picture, function(e) {
                            showNotification("Device in use by " + u.name, e)
                        })
                    })
                } else {
                    d.hide()
                }
                if (t.gcmConn.gcmConns[n]) a.find(".connect").text("Disconnect").addClass("btn-danger");
                else a.find(".connect").addClass("btn-default");
                a.find(".connect").click(function(e) {
                    e.stopPropagation();
                    var o = t.gcmConn.gcmConns[n];
                    if (o) {
                        o.destroy();
                        a.find(".connect").text("Connect")
                    } else {
                        a.find(".connect").text("Connect");
                        I(t, n, function() {})
                    }
                });
                a.click(function(e) {
                    var o = t.gcmConn.gcmConns[n];
                    if (o) {
                        D(o.serialno)
                    } else {
                        a.find(".connect").text("Connect");
                        I(t, n, function(e) {
                            D(e)
                        })
                    }
                });
                i.append(a)
            });
            $(s.contentWindow.document).find("#farms-list").append(i)
        })
    }
    var H;

    function Y() {
        chrome.storage.local.get("connect-automatically", function(t) {
            var n = t["connect-automatically"] !== false;
            Adb.devices(function(t) {
                if (t) {
                    V = true;
                    var o = [];
                    var i;
                    $.each(t, function(o, r) {
                        i = true;
                        if (!K[o]) {
                            a.sendEvent("found-device", r.name);
                            _(o);
                            var c = t[o];
                            var d = c.properties.indexOf("emulator") != -1 || c.properties.indexOf("vbox") != -1;
                            if (!d && H) {
                                if (n || chrome.app.window.get(o) || e.isRunning()) {
                                    D(o, true);
                                    if (!s && !chrome.app.window.get(o)) {
                                        var u = chrome.runtime.getManifest().name;
                                        chrome.notifications.create("never-start-automatically", {
                                            type: "basic",
                                            iconUrl: "/icon.png",
                                            title: u,
                                            message: "Vysor has connected to an Android device and is starting.",
                                            buttons: [{
                                                title: "Never Start Automatically"
                                            }]
                                        })
                                    }
                                }
                            }
                        }
                    });
                    K = t;
                    if (s) {
                        if (i || !e.isRunning()) $(s.contentWindow.document).find("#not-found").hide();
                        else $(s.contentWindow.document).find("#not-found").show()
                    }
                } else {
                    V = false;
                    K = {}
                }
                H = true
            })
        })
    }
    Y();
    var J;

    function X() {
        if (J) return;
        J = chrome.runtime.connectNative("com.clockworkmod.adb");
        J.onDisconnect.addListener(function() {
            J = null
        });
        J.postMessage({
            command: "start-server"
        })
    }

    function z() {
        if (s) {
            if (!V || e.isRunning()) {
                $(s.contentWindow.document).find("#connect-android").show();
                $(s.contentWindow.document).find("#no-devices").hide()
            } else {
                $(s.contentWindow.document).find("#connect-android").hide();
                $(s.contentWindow.document).find("#no-devices").show()
            }
            if (!V) {
                if (navigator.userAgent.indexOf("Windows NT 10") != -1 && J == null) {
                    $(s.contentWindow.document).find("#adb-server-status").show();
                    $(s.contentWindow.document).find("#adb-server-status").html("Windows 10 users MUST download the latest <a href='http://koush.com/post/universal-adb-driver' target='_blank'> Universal ADB Drivers</a>")
                } else {
                    $(s.contentWindow.document).find("#adb-server-status").show();
                    $(s.contentWindow.document).find("#adb-server-status").text("ADB not running. Click Find Devices to get started.")
                }
                X()
            } else {
                $(s.contentWindow.document).find("#adb-server-status").show();
                if (e.isRunning()) {
                    $(s.contentWindow.document).find("#adb-server-status").text("Using built-in Vysor ADB.")
                } else {
                    $(s.contentWindow.document).find("#adb-server-status").text("Using Android SDK ADB binary.")
                }
            }
        }
        Y();
        j();
        setTimeout(z, 1e3)
    }
    z();
    var G;

    function q() {
        G = throttleTimeout(G, null, 1e4, function() {
            var e = chrome.runtime.getManifest().name;
            chrome.notifications.create("reload", {
                type: "basic",
                iconUrl: "/icon.png",
                title: e,
                message: "There is an update available for Vysor.",
                buttons: [{
                    title: "Reload"
                }]
            })
        })
    }
    chrome.runtime.onUpdateAvailable.addListener(function() {
        A()
    });
    chrome.notifications.onButtonClicked.addListener(function(e, t) {
        if (e == "reload") {
            chrome.runtime.reload()
        } else if (e == "never-start-automatically") {
            chrome.storage.local.set({
                "connect-automatically": false
            });
            if (s) {
                $(s.contentWindow.document).find("#connect-automatically-check").prop("checked", false)
            }
            chrome.notifications.clear(e)
        }
    });
    chrome.notifications.onClicked.addListener(function(e, t) {});
    console.log("Vysor version", chrome.runtime.getManifest().version);
    console.log(navigator.userAgent)
})();